# Shopping Cart REST Server
#
# A complete example demonstrating:
# - HTTP REST API with multiple endpoints
# - SQLite persistence with prepared statements
# - Database transactions for checkout
# - URL query parameter parsing
# - Concurrent request handling with strands
#
# Build:
#   seqc --ffi-manifest examples/shopping-cart/sqlite.toml \
#        examples/shopping-cart/shopping-cart.seq -o shopping-cart
#
# Run:
#   ./shopping-cart
#
# Test with curl:
#   curl http://localhost:8080/products          # List products
#   curl http://localhost:8080/cart              # View cart
#   curl -X POST "http://localhost:8080/cart/add?product=1&qty=2"
#   curl -X POST "http://localhost:8080/cart/remove?id=1"
#   curl -X POST http://localhost:8080/cart/checkout
#
# Check database:
#   sqlite3 shop.db "SELECT * FROM products"
#   sqlite3 shop.db "SELECT * FROM cart_items"
#   sqlite3 shop.db "SELECT * FROM orders"

# SQLite FFI functions provided via --ffi-manifest (no include needed)

include std:stack-utils

# =============================================================================
# SQLite Constants and Helpers
# =============================================================================

: SQLITE_OK   ( -- Int ) 0 ;
: SQLITE_ROW  ( -- Int ) 100 ;
: SQLITE_DONE ( -- Int ) 101 ;

: db-ok? ( Int -- Int ) SQLITE_OK i.= ;
: db-row? ( Int -- Int ) SQLITE_ROW i.= ;

# =============================================================================
# HTTP Response Builders
# =============================================================================

: http-ok ( String -- String )
  dup string.length int->string
  "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: " swap string.concat
  "\r\n\r\n" string.concat
  swap string.concat
;

: http-bad-request ( String -- String )
  dup string.length int->string
  "HTTP/1.1 400 Bad Request\r\nContent-Type: text/plain\r\nContent-Length: " swap string.concat
  "\r\n\r\n" string.concat
  swap string.concat
;

: http-not-found ( String -- String )
  dup string.length int->string
  "HTTP/1.1 404 Not Found\r\nContent-Type: text/plain\r\nContent-Length: " swap string.concat
  "\r\n\r\n" string.concat
  swap string.concat
;

: http-error ( String -- String )
  dup string.length int->string
  "HTTP/1.1 500 Internal Server Error\r\nContent-Type: text/plain\r\nContent-Length: " swap string.concat
  "\r\n\r\n" string.concat
  swap string.concat
;

# =============================================================================
# HTTP Request Parsing
# =============================================================================

: http-request-line ( String -- String )
  "\r\n" string.split 0 variant.field-at
;

: http-request-path ( String -- String )
  http-request-line " " string.split 1 variant.field-at
;

: http-request-method ( String -- String )
  http-request-line " " string.split 0 variant.field-at
;

# Extract path without query string: "/cart/add?x=1" -> "/cart/add"
: http-path-base ( String -- String )
  http-request-path
  "?" string.split 0 variant.field-at
;

# Extract query string: "/cart/add?x=1&y=2" -> "x=1&y=2" (or "" if none)
: http-query-string ( String -- String )
  http-request-path
  dup "?" string.contains if
    "?" string.split
    dup variant.field-count 1 i.> if
      1 variant.field-at
    else
      drop ""
    then
  else
    drop ""
  then
;

# Parse a query param: "product=1&qty=2" "product" -> "1"
# Returns empty string if not found
: query-param ( String String -- String )
  # Stack: ( query-string param-name )
  "=" string.concat  # ( query-string "param-name=" )
  over swap          # ( query-string query-string "param-name=" )
  string.split       # ( query-string variant )
  dup variant.field-count 1 i.> if
    # Found the param
    1 variant.field-at  # Get part after "param-name="
    "&" string.split 0 variant.field-at  # Get value before next &
    nip  # Drop original query-string
  else
    drop drop ""  # Not found
  then
;

# =============================================================================
# Database Initialization
# =============================================================================

: init-schema ( Int -- Int Int )
  # Stack: ( db -- db success? )
  # Create products table
  dup "CREATE TABLE IF NOT EXISTS products (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    price INTEGER NOT NULL,
    stock INTEGER NOT NULL
  )" db-exec db-ok? 0 i.= if
    0  # ( db 0 ) - failure
  else
    # Create cart_items table
    dup "CREATE TABLE IF NOT EXISTS cart_items (
      id INTEGER PRIMARY KEY,
      product_id INTEGER NOT NULL,
      quantity INTEGER NOT NULL,
      FOREIGN KEY (product_id) REFERENCES products(id)
    )" db-exec db-ok? 0 i.= if
      0  # ( db 0 ) - failure
    else
      # Create orders table
      dup "CREATE TABLE IF NOT EXISTS orders (
        id INTEGER PRIMARY KEY,
        total INTEGER NOT NULL,
        item_count INTEGER NOT NULL,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
      )" db-exec db-ok? 0 i.= if
        0  # ( db 0 ) - failure
      else
        1  # ( db 1 ) - success
      then
    then
  then
;

: seed-products ( Int -- Int )
  # Stack: ( db -- db )
  # Only seed if products table is empty
  dup "SELECT COUNT(*) FROM products" db-prepare
  db-ok? if
    # Stack: ( db stmt )
    dup db-step SQLITE_ROW i.= if
      dup 0 db-column-int 0 i.= if
        # Table is empty, seed it
        db-finalize drop
        dup "INSERT INTO products (name, price, stock) VALUES ('Apple', 100, 50)" db-exec drop
        dup "INSERT INTO products (name, price, stock) VALUES ('Banana', 75, 30)" db-exec drop
        dup "INSERT INTO products (name, price, stock) VALUES ('Orange', 120, 25)" db-exec drop
        dup "INSERT INTO products (name, price, stock) VALUES ('Milk', 350, 20)" db-exec drop
        dup "INSERT INTO products (name, price, stock) VALUES ('Bread', 250, 15)" db-exec drop
        "Seeded 5 products" io.write-line
      else
        db-finalize drop
        "Products already exist" io.write-line
      then
    else
      db-finalize drop
    then
  else
    # Prepare failed - finalize to prevent leak
    db-finalize drop
    "Warning: Could not check products table" io.write-line
  then
;

: init-db ( -- Int )
  # Returns: ( db-handle ) or 0 on failure
  "shop.db" db-open db-ok? if
    # Stack: ( db )
    init-schema if
      seed-products
      # db is on stack
    else
      "Failed to create schema" io.write-line
      drop 0
    then
  else
    drop  # drop the null handle
    "Failed to open database" io.write-line
    0
  then
;

# =============================================================================
# Product Queries
# =============================================================================

# Format a single product row as text
: format-product-row ( Int -- String )
  # Stack: ( stmt )
  # Columns: id(0), name(1), price(2), stock(3)
  # Simple format: just concatenate in order
  "  "
  over 0 db-column-int int->string string.concat
  ". " string.concat
  over 1 db-column-text string.concat
  " - $" string.concat
  over 2 db-column-int int->string string.concat
  " (stock: " string.concat
  over 3 db-column-int int->string string.concat
  ")" string.concat
  nip
;

# Recursive helper to collect product rows
: collect-products ( Int String -- String )
  # Stack: ( stmt accumulated )
  over db-step
  dup SQLITE_ROW i.= if
    drop  # drop step result
    # Get this row
    over format-product-row
    # Add newline if not first
    over string.length 0 i.> if
      "\n" swap string.concat
    then
    # Append to accumulated
    string.concat
    collect-products  # Recurse
  else
    SQLITE_DONE i.= if
      # Finalize and return
      swap db-finalize drop
    else
      # Error - finalize statement to prevent leak
      # Stack: ( stmt accumulated ) - step result already consumed by comparison
      swap db-finalize drop  # finalize stmt, drop result
      drop "ERROR"  # drop accumulated, return error
    then
  then
;

: list-products ( Int -- Int String )
  # Stack: ( db -- db result-string )
  dup "SELECT id, name, price, stock FROM products ORDER BY id" db-prepare
  # Stack after db-prepare: ( db stmt result )
  db-ok? if
    # Stack: ( db stmt )
    "" collect-products
    # Stack after collect: ( db result-string )
    dup "ERROR" string.equal? if
      drop "Error querying products"
    else
      "Products:\n" swap string.concat
    then
  else
    # Stack: ( db stmt ) - finalize to prevent leak (safe even if NULL)
    db-finalize drop "Error preparing query"
  then
;

# =============================================================================
# Cart Operations
# =============================================================================

: format-cart-row ( Int -- String )
  # Stack: ( stmt )
  # Columns: cart_id(0), product_name(1), quantity(2), price(3), subtotal(4)
  # Simple format: just concatenate in order
  "  #"
  over 0 db-column-int int->string string.concat
  ": " string.concat
  over 1 db-column-text string.concat
  " x " string.concat
  over 2 db-column-int int->string string.concat
  " @ $" string.concat
  over 3 db-column-int int->string string.concat
  " = $" string.concat
  over 4 db-column-int int->string string.concat
  nip
;

: collect-cart-items ( Int String -- String )
  over db-step
  dup SQLITE_ROW i.= if
    drop
    over format-cart-row
    over string.length 0 i.> if
      "\n" swap string.concat
    then
    string.concat
    collect-cart-items
  else
    SQLITE_DONE i.= if
      swap db-finalize drop
    else
      # Error - finalize statement to prevent leak
      # Stack: ( stmt accumulated ) - step result already consumed by comparison
      swap db-finalize drop  # finalize stmt, drop result
      drop "ERROR"  # drop accumulated, return error
    then
  then
;

: list-cart ( Int -- Int String )
  # Stack: ( db -- db result-string )
  dup "SELECT c.id, p.name, c.quantity, p.price, (c.quantity * p.price) as subtotal
       FROM cart_items c
       JOIN products p ON c.product_id = p.id
       ORDER BY c.id" db-prepare
  # Stack after db-prepare: ( db stmt result )
  db-ok? if
    # Stack: ( db stmt )
    "" collect-cart-items
    # Stack after collect: ( db result-string )
    dup "ERROR" string.equal? if
      drop "Error querying cart"
    else
      dup string.length 0 i.= if
        drop "Cart is empty"
      else
        "Cart:\n" swap string.concat
      then
    then
  else
    # Stack: ( db stmt ) - finalize to prevent leak (safe even if NULL)
    db-finalize drop "Error preparing cart query"
  then
;

# Insert item into cart (assumes stock was already checked)
: insert-cart-item ( Int Int Int -- Int String )
  # Stack: ( db product_id qty )
  2 pick "INSERT INTO cart_items (product_id, quantity) VALUES (?, ?)" db-prepare
  db-ok? if
    dup 3 pick 1 swap db-bind-int drop  # bind product_id
    dup 2 pick 2 swap db-bind-int drop  # bind qty
    dup db-step drop
    db-finalize 3drop
    "Added to cart"
  else
    db-finalize 3drop
    "Failed to prepare insert"
  then
;

# Check stock and insert if sufficient
: check-stock-and-insert ( Int Int Int Int Int -- Int String )
  # Stack: ( db product_id qty stmt stock )
  3 pick i.< if
    db-finalize 3drop
    "Insufficient stock"
  else
    db-finalize drop
    insert-cart-item
  then
;

# Add item to cart using prepared statement (prevents SQL injection)
: add-to-cart ( Int Int Int -- Int String )
  # Stack: ( db product_id qty -- db result )
  2 pick "SELECT stock FROM products WHERE id = ?" db-prepare
  db-ok? if
    dup 3 pick 1 swap db-bind-int drop
    dup db-step SQLITE_ROW i.= if
      dup 0 db-column-int check-stock-and-insert
    else
      db-finalize 3drop
      "Product not found"
    then
  else
    db-finalize 3drop
    "Failed to prepare query"
  then
;

# Remove item from cart using prepared statement (prevents SQL injection)
: remove-from-cart ( Int Int -- Int String )
  # Stack: ( db cart_item_id -- db result )
  over "DELETE FROM cart_items WHERE id = ?" db-prepare
  db-ok? if
    # Stack: ( db cart_item_id stmt )
    dup rot 1 swap db-bind-int drop  # bind cart_item_id to param 1
    # Stack now: ( db stmt )
    dup db-step drop  # keep stmt, call step, drop result
    db-finalize drop  # finalize stmt
    "Removed from cart"
  else
    # Stack: ( db cart_item_id stmt ) - finalize and clean up, keep db
    db-finalize drop drop
    "Failed to prepare delete"
  then
;

# =============================================================================
# Checkout with Transaction
# =============================================================================

: calculate-cart-total ( Int -- Int Int Int )
  # Stack: ( db -- db total_price item_count )
  dup "SELECT COALESCE(SUM(c.quantity * p.price), 0), COALESCE(SUM(c.quantity), 0)
       FROM cart_items c
       JOIN products p ON c.product_id = p.id" db-prepare
  # Stack: ( db stmt result )
  db-ok? if
    # Stack: ( db stmt )
    dup db-step SQLITE_ROW i.= if
      # Stack: ( db stmt )
      dup 0 db-column-int  # ( db stmt total )
      over 1 db-column-int # ( db stmt total count )
      rot db-finalize drop # ( db total count )
    else
      # No row returned
      db-finalize drop
      0 0  # ( db 0 0 )
    then
  else
    # Prepare failed - finalize to prevent leak (safe even if NULL)
    db-finalize drop
    0 0  # ( db 0 0 )
  then
;

: check-stock-available ( Int -- Int Int )
  # Stack: ( db -- db sufficient? )
  # Check that all cart items have sufficient stock
  dup "SELECT COUNT(*) FROM cart_items c
       JOIN products p ON c.product_id = p.id
       WHERE c.quantity > p.stock" db-prepare
  db-ok? if
    dup db-step SQLITE_ROW i.= if
      dup 0 db-column-int 0 =  # True if count is 0 (no insufficient items)
      swap db-finalize drop
    else
      db-finalize drop
      0  # Error, return false
    then
  else
    # Prepare failed - finalize to prevent leak (safe even if NULL)
    db-finalize drop
    0  # Error, return false
  then
;

: update-stock ( Int -- Int Int )
  # Stack: ( db -- db success? )
  # Only update if stock won't go negative
  dup "UPDATE products SET stock = stock - (
    SELECT c.quantity FROM cart_items c WHERE c.product_id = products.id
  ) WHERE id IN (SELECT product_id FROM cart_items)
    AND stock >= (SELECT c.quantity FROM cart_items c WHERE c.product_id = products.id)" db-exec
  db-ok?
;

: create-order ( Int Int Int -- Int Int )
  # Stack: ( db total count -- db success? )
  # Use prepared statement to prevent SQL injection
  2 pick "INSERT INTO orders (total, item_count) VALUES (?, ?)" db-prepare
  db-ok? if
    # Stack: ( db total count stmt )
    dup 3 pick 1 swap db-bind-int drop  # bind total to param 1
    dup 2 pick 2 swap db-bind-int drop  # bind count to param 2
    dup db-step drop  # keep stmt, call step, drop result
    db-finalize 3drop  # finalize stmt and drop total count
    1  # success
  else
    # Stack: ( db total count stmt ) - finalize and clean up
    db-finalize 3drop
    0  # failure
  then
;

: clear-cart ( Int -- Int Int )
  # Stack: ( db -- db success? )
  dup "DELETE FROM cart_items" db-exec
  db-ok?
;

# Build checkout success message
: checkout-success-message ( Int Int -- String )
  # Stack: ( total count -- message )
  swap int->string swap int->string
  "Checkout successful! Order total: $" rot string.concat
  " (" string.concat
  swap string.concat
  " items)" string.concat
;

# Try to clear cart and commit, rollback on failure
: try-clear-and-commit ( Int Int Int -- Int String )
  # Stack: ( db total count )
  2 pick clear-cart if
    drop
    2 pick "COMMIT" db-exec drop
    checkout-success-message
  else
    drop
    2 pick "ROLLBACK" db-exec 3drop
    "Checkout failed: could not clear cart"
  then
;

# Try to create order, then clear cart
: try-create-order ( Int Int Int Int Int -- Int String )
  # Stack: ( db total count total count )
  4 pick rot rot create-order if
    drop try-clear-and-commit
  else
    drop
    2 pick "ROLLBACK" db-exec 3drop
    "Checkout failed: could not create order"
  then
;

# Try to update stock, then create order
: try-update-stock ( Int Int Int Int Int -- Int String )
  # Stack: ( db total count total count )
  4 pick update-stock if
    drop try-create-order
  else
    drop
    4 pick "ROLLBACK" db-exec drop
    3drop drop
    "Checkout failed: could not update stock"
  then
;

# Execute checkout transaction
: execute-checkout ( Int Int Int -- Int String )
  # Stack: ( db total count )
  2dup
  4 pick "BEGIN TRANSACTION" db-exec drop
  try-update-stock
;

: checkout ( Int -- Int String )
  calculate-cart-total
  dup 0 i.= if
    drop drop "Cart is empty - nothing to checkout"
  else
    2 pick check-stock-available if
      drop execute-checkout
    else
      3drop "Checkout failed: insufficient stock for one or more items"
    then
  then
;

# =============================================================================
# HTTP Router
# =============================================================================

: handle-get-products ( Int String -- Int String )
  # Stack: ( db request -- db response )
  drop
  list-products http-ok
;

: handle-get-cart ( Int String -- Int String )
  drop
  list-cart http-ok
;

# Check if product param is missing
: product-missing? ( String String -- String String Bool )
  over string.length 0 i.= ;

# Check if qty param is missing
: qty-missing? ( String String -- String String Bool )
  dup string.length 0 i.= ;

# Try to parse and validate add-to-cart params after basic validation
: try-parse-add-params ( Int String String String -- )
  # Stack: ( db request product_str qty_str )
  string->int if
    swap string->int if
      swap dup 0 i.> if
        rot drop true
      else
        3drop "Quantity must be positive" false
      then
    else
      3drop "Invalid product ID (must be a number)" false
    then
  else
    3drop "Invalid quantity (must be a number)" false
  then
;

# Validate and parse add-to-cart parameters
# Returns: ( db product_id qty true ) on success, or ( db error_msg false ) on failure
: parse-add-params ( Int String String String -- )
  [ product-missing? ] [ 3drop "Missing 'product' parameter" false ]
  [ qty-missing? ]     [ 3drop "Missing 'qty' parameter" false ]
  [ true ]             [ try-parse-add-params ]
  3 cond
;

: handle-add-to-cart ( Int String -- Int String )
  # Stack: ( db request -- db response )
  dup http-query-string
  dup "product" query-param
  swap "qty" query-param
  parse-add-params
  if
    add-to-cart http-ok
  else
    http-bad-request
  then
;

: handle-remove-from-cart ( Int String -- Int String )
  dup http-query-string "id" query-param
  dup string.length 0 i.= if
    drop drop
    "Missing 'id' parameter" http-bad-request
  else
    # Parse id string to int
    string->int if
      # id parsed successfully ( db request id_int )
      nip  # drop request
      remove-from-cart
      http-ok
    else
      drop drop
      "Invalid id (must be a number)" http-bad-request
    then
  then
;

: handle-checkout ( Int String -- Int String )
  drop
  checkout http-ok
;

# Helper to get method and path from request
: request-method ( String -- String )
  http-request-method
;

: request-path ( String -- String )
  http-path-base
;

# Route GET requests
: route-get ( Int String -- Int String )
  [ dup request-path "/products" string.equal? ] [ handle-get-products ]
  [ dup request-path "/cart" string.equal? ]     [ handle-get-cart ]
  [ dup request-path "/" string.equal? ]         [ drop "Shopping Cart API\n\nEndpoints:\n  GET  /products - List products\n  GET  /cart - View cart\n  POST /cart/add?product=ID&qty=N - Add to cart\n  POST /cart/remove?id=N - Remove from cart\n  POST /cart/checkout - Complete purchase" http-ok ]
  [ true ]                                       [ drop "Not found" http-not-found ]
  4 cond
;

# Route POST requests
: route-post ( Int String -- Int String )
  [ dup request-path "/cart/add" string.equal? ]      [ handle-add-to-cart ]
  [ dup request-path "/cart/remove" string.equal? ]   [ handle-remove-from-cart ]
  [ dup request-path "/cart/checkout" string.equal? ] [ handle-checkout ]
  [ true ]                                            [ drop "Not found" http-not-found ]
  4 cond
;

: route ( Int String -- Int String )
  # Stack: ( db request -- db response )
  [ dup request-method "GET" string.equal? ]  [ route-get ]
  [ dup request-method "POST" string.equal? ] [ route-post ]
  [ true ]                                    [ drop "Method not allowed" http-bad-request ]
  3 cond
;

# =============================================================================
# Connection Handling
# =============================================================================

: handle-connection ( Int -- )
  # Stack: ( socket -- )
  # Each request opens its own DB connection for simplicity
  "shop.db" db-open db-ok? if
    # Stack: ( socket db )
    swap dup tcp.read  # ( db socket request )
    rot                # ( socket request db )
    swap route         # ( socket db response )
    rot                # ( db response socket )
    tuck tcp.write     # ( db socket )
    tcp.close          # ( db )
    db-close drop      # close our db connection
  else
    # DB open failed
    drop  # drop null db handle
    "HTTP/1.1 500 Internal Server Error\r\nContent-Length: 13\r\n\r\nDatabase error"
    over tcp.write
    tcp.close
  then
;

: worker ( Int -- )
  # Stack: ( channel -- )
  dup chan.receive  # keep channel ID, get socket
  swap chan.close   # close the channel (no longer needed)
  handle-connection
;

: accept-loop ( Int -- )
  # Stack: ( listener -- )
  dup tcp.accept
  # Stack: ( listener client )

  chan.make
  # Stack: ( listener client chan )

  dup [ worker ] strand.spawn
  # After dup: ( listener client chan chan )
  # After strand.spawn: ( listener client chan chan strand_id )

  drop drop
  # After drops: ( listener client chan )

  # Send client through channel
  chan.send
  # Stack: ( listener )

  accept-loop
;

# =============================================================================
# Main Entry Point
# =============================================================================

: main ( -- )
  "Initializing Shopping Cart Server..." io.write-line

  # Initialize DB schema and seed data, then close the setup connection
  init-db
  dup 0 i.= if
    drop
    "Failed to initialize database" io.write-line
  else
    db-close drop  # Close the setup connection
    "Database initialized" io.write-line
    "" io.write-line
    "Starting server on port 8080..." io.write-line
    "API Endpoints:" io.write-line
    "  GET  http://localhost:8080/           - API info" io.write-line
    "  GET  http://localhost:8080/products   - List products" io.write-line
    "  GET  http://localhost:8080/cart       - View cart" io.write-line
    "  POST http://localhost:8080/cart/add?product=ID&qty=N" io.write-line
    "  POST http://localhost:8080/cart/remove?id=N" io.write-line
    "  POST http://localhost:8080/cart/checkout" io.write-line
    "" io.write-line

    8080 tcp.listen
    "Listening..." io.write-line
    accept-loop
  then
;
