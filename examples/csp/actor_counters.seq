# Actor Counters - CSP/Actor Model Demo (4-Tier Hierarchical Aggregation)
#
# This example demonstrates Communicating Sequential Processes (CSP) and the
# Actor model in Seq with 4-tier hierarchical aggregation:
#
# Architecture:
#   - Company actor: top-level aggregate, receives reports from regions
#   - Region actors: aggregate reports from districts, forward to company
#   - District actors: aggregate reports from stores, forward to region
#   - Store actors: maintain individual counters, batch reports to district
#   - Unified registry maps paths to channel IDs for all actor levels
#   - Request-response pattern for queries
#   - Fire-and-forget pattern for aggregation reports
#
# Aggregation Pattern:
#   - Stores batch updates: after every 5 increments, report delta to district
#   - Parent levels (district/region/company) forward immediately on each update
#   - This balances message volume reduction with aggregate freshness
#
# URL scheme (RESTful - path depth determines level):
#   GET  /acme/west/seattle/0001           -> store count (4 segments)
#   POST /acme/west/seattle/0001/increment -> increment store
#   GET  /acme/west/seattle                -> district aggregate (3 segments)
#   GET  /acme/west                        -> region aggregate (2 segments)
#   GET  /acme                             -> company aggregate (1 segment)
#
# Usage:
#   seqc --output /tmp/actors examples/csp/actor_counters.seq
#   /tmp/actors
#   curl http://localhost:8080/acme/west/seattle/0001
#   curl -X POST http://localhost:8080/acme/west/seattle/0001/increment
#   curl http://localhost:8080/acme/west/seattle
#   curl http://localhost:8080/acme/west
#   curl http://localhost:8080/acme

include std:http

# ============================================================================
#                              MESSAGE PROTOCOL
# ============================================================================
#
# Type-safe message protocol using ADTs:
#   - Get: request current count, includes response channel
#   - Increment: increment counter, includes response channel
#   - Report: fire-and-forget aggregation report (delta + total)
#
# Responses are single Int values (the count)

union Message {
  Get { response_chan: Int }
  Increment { response_chan: Int }
  Report { delta: Int, total: Int }
}

# Report threshold - send to parent every N increments
: report-threshold ( -- Int )
  5
;

# ============================================================================
#                              STORE ACTOR
# ============================================================================
#
# Each store is an actor that:
#   1. Receives messages on its channel
#   2. Maintains a counter through recursion (TCO)
#   3. Responds on the caller's response channel
#   4. Reports to parent (district) every N increments
#
# State maintained via recursion:
#   - count: current counter value
#   - pending: changes since last report to parent
#
# The actor runs forever via tail-recursive loop.

# Store actor entry point
# Receives ( my-chan parent-chan ) via spawn's stack cloning
: store-actor ( Int Int -- )
  swap                       # ( parent-chan my-chan )
  0 0 store-loop             # Start with count=0, pending=0
;

# Store actor main loop - handles messages forever
# Stack: ( parent-chan my-chan count pending -- ) [never returns]
: store-loop ( Int Int Int Int -- )
  # Receive on my-chan (which is at depth 2)
  # NOTE: We drop the success flag because this is an infinite actor loop.
  # If receive fails, there's no meaningful recovery - the actor dies.
  # The type checker can't express divergent early-exit patterns.
  2 pick chan.receive             # ( parent my count pending msg success )
  drop                            # drop success flag (actor loop pattern)

  match
    Get { >response_chan } ->
      # Return current count on response channel
      # Stack: ( parent my count pending response_chan )
      2 pick swap chan.send       # ( parent my count pending success )
      drop                        # drop success flag (fire-and-forget response)
      store-loop

    Increment { >response_chan } ->
      # Increment counter and return new count
      # Stack: ( parent my count pending response_chan )
      rot 1 i.add              # ( parent my pending response_chan count+1 )
      dup rot chan.send           # ( parent my pending count+1 success )
      drop                        # drop success flag (fire-and-forget response)
      swap 1 i.add             # ( parent my count+1 pending+1 )

      # Check if we should report to parent
      dup report-threshold i.>= if
        # Time to report! Send delta to parent
        dup                  # ( parent my count pending pending )
        2 pick               # ( parent my count pending pending count )
        Make-Report          # ( parent my count pending report-msg )
        4 pick chan.send          # ( parent my count pending success )
        drop                      # drop success flag (fire-and-forget to parent)
        drop 0               # ( parent my count 0 ) - reset pending
      then
      store-loop

    Report ->
      # Stores don't receive Report messages - ignore
      # Stack: ( parent my count pending delta total )
      drop drop              # ( parent my count pending )
      store-loop
  end
;

# ============================================================================
#                            DISTRICT ACTOR
# ============================================================================
#
# District actor aggregates reports from stores and forwards immediately.
#   - Receives REPORT messages from stores (op=2)
#   - Receives GET messages from HTTP clients (op=0)
#   - Maintains aggregate total across all stores
#   - Forwards to region immediately on every update

# District actor entry point
# Receives ( my-chan parent-chan ) via spawn's stack cloning
: district-actor ( Int Int -- )
  swap                       # ( parent-chan my-chan )
  0 district-loop            # Start with total=0
;

# District actor main loop - simple: aggregate and forward immediately
# Stack: ( parent-chan my-chan total -- ) [never returns]
: district-loop ( Int Int Int -- )
  # NOTE: Actor loop - drop success flag (see store-loop comment)
  over chan.receive               # ( parent my total msg success )
  drop                            # drop success flag (actor loop pattern)

  match
    Get { >response_chan } ->
      # Return aggregate total on response channel
      # Stack: ( parent my total response_chan )
      over swap chan.send         # ( parent my total success )
      drop                        # drop success flag (fire-and-forget)
      district-loop

    Report { >delta } ->
      # Add delta, forward to region immediately
      # Stack: ( parent my total delta )
      dup rot i.add            # ( parent my delta total+delta )
      tuck                   # ( parent my total' delta total' )
      Make-Report            # ( parent my total' report-msg )
      3 pick chan.send            # ( parent my total' success )
      drop                        # drop success flag (fire-and-forget)
      district-loop

    Increment ->
      # Districts don't handle Increment - ignore
      # Stack: ( parent my total response_chan )
      drop                   # ( parent my total )
      district-loop
  end
;

# ============================================================================
#                            REGION ACTOR
# ============================================================================
#
# Region actor aggregates reports from districts.
#   - Receives REPORT messages from districts (op=2)
#   - Receives GET messages from HTTP clients (op=0)
#   - Forwards to company immediately on every update

# Region actor entry point
: region-actor ( Int Int -- )
  swap                       # ( parent-chan my-chan )
  0 region-loop              # Start with total=0
;

# Region actor main loop - simple: aggregate and forward immediately
# Stack: ( parent-chan my-chan total -- ) [never returns]
: region-loop ( Int Int Int -- )
  # NOTE: Actor loop - drop success flag (see store-loop comment)
  over chan.receive               # ( parent my total msg success )
  drop                            # drop success flag (actor loop pattern)

  match
    Get { >response_chan } ->
      # Return aggregate total on response channel
      # Stack: ( parent my total response_chan )
      over swap chan.send         # ( parent my total success )
      drop                        # drop success flag (fire-and-forget)
      region-loop

    Report { >delta } ->
      # Add delta, forward to company immediately
      # Stack: ( parent my total delta )
      dup rot i.add            # ( parent my delta total+delta )
      tuck                   # ( parent my total' delta total' )
      Make-Report            # ( parent my total' report-msg )
      3 pick chan.send            # ( parent my total' success )
      drop                        # drop success flag (fire-and-forget)
      region-loop

    Increment ->
      # Regions don't handle Increment - ignore
      # Stack: ( parent my total response_chan )
      drop                   # ( parent my total )
      region-loop
  end
;

# ============================================================================
#                            COMPANY ACTOR
# ============================================================================
#
# Company actor aggregates reports from regions.
#   - Top of hierarchy - no parent to report to
#   - Receives REPORT messages from regions (op=2)
#   - Receives GET messages from HTTP clients (op=0)

# Company actor entry point
: company-actor ( Int -- )
  0 company-loop
;

# Company actor main loop
# Stack: ( my-chan total -- ) [never returns]
: company-loop ( Int Int -- )
  # NOTE: Actor loop - drop success flag (see store-loop comment)
  over chan.receive               # ( my-chan total msg success )
  drop                            # drop success flag (actor loop pattern)

  match
    Get { >response_chan } ->
      # Return aggregate total on response channel
      # Stack: ( my-chan total response_chan )
      over swap chan.send         # ( my-chan total success )
      drop                        # drop success flag (fire-and-forget)
      company-loop

    Report { >delta } ->
      # Add delta (no forwarding - company is top of hierarchy)
      # Stack: ( my-chan total delta )
      i.add                  # ( my-chan total+delta )
      company-loop

    Increment ->
      # Company doesn't handle Increment - ignore
      # Stack: ( my-chan total response_chan )
      drop                   # ( my-chan total )
      company-loop
  end
;

# ============================================================================
#                              REGISTRIES
# ============================================================================
#
# Four registries (one per hierarchy level):
#   - Company registry: "acme" -> company channel
#   - Region registry: "acme/west" -> region channel
#   - District registry: "acme/west/seattle" -> district channel
#   - Store registry: "acme/west/seattle/0001" -> store channel

# Create an empty registry
# Stack: ( -- registry )
: make-registry ( -- Variant )
  map.make
;

# Look up in a registry
# Stack: ( registry path -- channel-id found? )
: lookup-store ( Variant String -- Int Bool )
  map.get   # ( value found? ) - errors are values, not crashes
;

# Create a company actor and register it
# Stack: ( company-registry company-name -- company-registry' company-chan )
: create-company ( Variant String -- Variant Int )
  chan.make               # ( registry name chan )
  dup                        # ( registry name chan chan )
  [ company-actor ] spawn    # ( registry name chan chan strand-id )
  drop drop                  # ( registry name chan )

  dup                        # ( registry name chan chan )
  3 roll                     # ( name chan chan registry )
  3 roll                     # ( chan chan registry name )
  3 roll                     # ( chan registry name chan )
  map.set                    # ( chan registry' )
  swap                       # ( registry' chan )
;

# Create a region actor and register it
# Stack: ( parent-chan region-registry region-path -- region-registry' region-chan )
: create-region ( Int Variant String -- Variant Int )
  chan.make               # ( parent registry path chan )
  dup                        # ( parent registry path chan chan )
  4 pick                     # ( parent registry path chan chan parent )
  [ region-actor ] spawn     # ( parent registry path chan chan parent strand-id )
  3drop             # ( parent registry path chan )

  dup                        # ( parent registry path chan chan )
  3 roll                     # ( parent path chan chan registry )
  3 roll                     # ( parent chan chan registry path )
  3 roll                     # ( parent chan registry path chan )
  map.set                    # ( parent chan registry' )
  swap                       # ( parent registry' chan )
  rot drop                   # ( registry' chan )
;

# Create a district actor and register it
# Stack: ( parent-chan district-registry district-path -- district-registry' district-chan )
: create-district ( Int Variant String -- Variant Int )
  chan.make               # ( parent registry path chan )
  dup                        # ( parent registry path chan chan )
  4 pick                     # ( parent registry path chan chan parent )
  [ district-actor ] spawn   # ( parent registry path chan chan parent strand-id )
  3drop             # ( parent registry path chan )

  dup                        # ( parent registry path chan chan )
  3 roll                     # ( parent path chan chan registry )
  3 roll                     # ( parent chan chan registry path )
  3 roll                     # ( parent chan registry path chan )
  map.set                    # ( parent chan registry' )
  swap                       # ( parent registry' chan )
  rot drop                   # ( registry' chan )
;

# ============================================================================
#                          STORE GENERATION
# ============================================================================
#
# Generate a hierarchical set of stores:
#   companies × regions × districts × stores
#
# Each store gets a unique path like "acme/west/seattle/0042"

# Pad a string with leading zeros
# Stack: ( str count -- padded-str )
: pad-zeros ( String Int -- String )
  dup 0 i.<= if
    drop
  else
    "0" rot string.concat swap
    1 i.subtract pad-zeros
  then
;

# Pad a string to a minimum width with leading zeros
# Stack: ( str width -- padded-str )
: pad-to-width ( String Int -- String )
  over string.length        # ( str width len )
  over swap i.subtract        # ( str width padding )
  nip                       # ( str padding )
  pad-zeros                 # ( padded-str )
;

# Build a store path from components
# Stack: ( company region district store-num -- path )
: build-path ( String String String Int -- String )
  int->string               # ( company region district store-str )
  # Pad store number to 4 digits (e.g., 1 -> "0001")
  4 pad-to-width            # ( company region district padded-store )

  # Stack: ( company region district store )
  # Build: company/region/district/store

  # Join district "/" store -> "district/store"
  swap "/" string.concat    # ( company region store "district/" )
  swap string.concat        # ( company region "district/store" )

  # Join region "/" ... -> "region/district/store"
  swap "/" string.concat    # ( company "district/store" "region/" )
  swap string.concat        # ( company "region/district/store" )

  # Join company "/" ... -> "company/region/district/store"
  swap "/" string.concat    # ( "region/district/store" "company/" )
  swap string.concat        # ( "company/region/district/store" )
;

# Create a single store with parent channel
# Stack: ( parent-chan path registry -- registry' )
: create-store ( Int String Variant -- Variant )
  chan.make               # ( parent path registry chan )

  # Spawn the store actor: needs ( my-chan parent-chan ) on stack
  dup                        # ( parent path registry chan chan )
  4 pick                     # ( parent path registry chan chan parent )
  [ store-actor ] spawn      # ( parent path registry chan chan parent strand-id )
  3drop             # ( parent path registry chan )

  # Now: ( parent path registry chan )
  # Need: ( registry path chan ) for map.set

  # rot on top 3 ( path registry chan ) -> ( registry chan path )
  rot                        # ( parent registry chan path )

  # 3 roll brings parent to top
  3 roll                     # ( registry chan path parent )
  drop                       # ( registry chan path )

  # Now we have ( registry chan path )
  # Need ( registry path chan )
  # swap swaps top 2: ( registry path chan )
  swap                       # ( registry path chan )
  map.set                    # ( registry' )
;

# Number of stores per district
: stores-per-district ( -- Int )
  10   # Start with 10 stores per district for testing
;

# ============================================================================
#                         HIERARCHY GENERATION
# ============================================================================
#
# 4-tier actor hierarchy using a SINGLE flat registry:
#   - "acme" -> company actor channel
#   - "acme/west" -> region actor channel
#   - "acme/west/seattle" -> district actor channel
#   - "acme/west/seattle/0001" -> store actor channel
#
# This simplifies stack management - one registry holds all levels.
# Path segment count determines level (1=company, 2=region, 3=district, 4=store).

# Helper: Generate stores for a district (recursive)
# Stack: ( parent-chan prefix counter registry -- registry' )
: gen-stores-loop ( Int String Int Variant -- Variant )
  over 0 i.<= if
    nip nip nip
  else
    over int->string 4 pad-to-width
    3 pick swap string.concat      # ( parent prefix counter registry path )
    over 5 pick rot rot            # ( parent prefix counter registry parent path registry )
    create-store                   # ( parent prefix counter registry new-reg )
    nip swap 1 i.subtract swap       # ( parent prefix counter-1 new-reg )
    gen-stores-loop
  then
;

# Create stores for a district
# Stack: ( registry district-chan district-path -- registry' )
: add-stores ( Variant Int String -- Variant )
  "/" string.concat                # ( registry district-chan prefix )
  stores-per-district              # ( registry district-chan prefix count )
  3 roll                           # ( district-chan prefix count registry )
  gen-stores-loop                  # ( registry' )
;


# Build 4-tier hierarchy with single unified registry
# Stack: ( -- registry )
: init-four-tier ( -- Variant )
  make-registry
  "Initializing 4-tier actor hierarchy..." io.write-line

  # === ACME COMPANY ===
  "acme" create-company           # ( registry acme-chan )

  # === ACME/WEST REGION ===
  swap "acme/west" create-region  # ( registry west-chan )

  # === ACME/WEST/SEATTLE DISTRICT ===
  swap "acme/west/seattle" create-district  # ( registry seattle-chan )
  "acme/west/seattle" add-stores  # ( registry )

  # === ACME/WEST/PORTLAND DISTRICT ===
  # Need to look up west-chan again
  dup "acme/west" lookup-store drop  # ( registry west-chan )
  swap "acme/west/portland" create-district  # ( registry portland-chan )
  "acme/west/portland" add-stores  # ( registry )

  # === ACME/EAST REGION ===
  dup "acme" lookup-store drop    # ( registry acme-chan )
  swap "acme/east" create-region  # ( registry east-chan )

  # === ACME/EAST/BOSTON DISTRICT ===
  swap "acme/east/boston" create-district  # ( registry boston-chan )
  "acme/east/boston" add-stores   # ( registry )

  # === ACME/EAST/NEWYORK DISTRICT ===
  dup "acme/east" lookup-store drop  # ( registry east-chan )
  swap "acme/east/newyork" create-district  # ( registry newyork-chan )
  "acme/east/newyork" add-stores  # ( registry )

  # Print summary
  "  Company: acme" io.write-line
  "  Regions: acme/west, acme/east" io.write-line
  "  Districts: seattle, portland, boston, newyork" io.write-line
  dup map.size int->string " actors in unified registry" string.concat io.write-line
;



# ============================================================================
#                            HTTP HANDLING
# ============================================================================
#
# RESTful routes - path depth determines resource level:
#   GET  /acme/west/seattle/0001           -> store (4 segments)
#   POST /acme/west/seattle/0001/increment -> increment store
#   GET  /acme/west/seattle                -> district aggregate (3 segments)
#   GET  /acme/west                        -> region aggregate (2 segments)
#   GET  /acme                             -> company aggregate (1 segment)

# Count path segments (splits on "/" and counts non-empty parts)
# Stack: ( path -- count )
: count-path-segments ( String -- Int )
  # Strip leading / if present
  dup 0 string.char-at 47 i.= if  # 47 = '/'
    1 over string.length 1 i.subtract string.substring
  then
  "/" string.split variant.field-count
;

# Handle an HTTP request
# Stack: ( registry socket -- registry )
: handle-request ( Variant Int -- Variant )
  # Read the HTTP request
  dup tcp.read               # ( registry socket request )

  # Extract path from request
  dup http-request-path      # ( registry socket request path )
  swap http-request-method   # ( registry socket path method )

  # Dispatch based on path
  dispatch-request
;

# Dispatch request to appropriate handler
# Stack: ( registry socket path method -- registry )
: dispatch-request ( Variant Int String String -- Variant )
  # Check if path ends with /increment
  over "/increment" string-ends-with? if
    # Increment request - strip suffix and do increment
    drop                     # ( registry socket path )
    dup string.length 10 i.subtract 0 swap string.substring  # remove "/increment"
    do-increment
  else
    drop                     # ( registry socket path )
    # Count segments to determine resource level
    dup count-path-segments  # ( registry socket path segments )
    dup 4 i.= if
      # 4 segments = store query
      drop do-get-store
    else
      dup 3 i.= if
        # 3 segments = district aggregate
        drop do-get-actor
      else
        dup 2 i.= if
          # 2 segments = region aggregate
          drop do-get-actor
        else
          dup 1 i.= if
            # 1 segment = company aggregate
            drop do-get-actor
          else
            # Unknown - return 404
            drop drop
            "Not found - use 1-4 segments: company/region/district/store" http-not-found
            over tcp.write
            tcp.close
          then
        then
      then
    then
  then
;

# Check if string ends with suffix
# Stack: ( str suffix -- bool )
: string-ends-with? ( String String -- Bool )
  dup string.length         # ( str suffix suffix-len )
  rot dup string.length     # ( suffix suffix-len str str-len )
  rot                       # ( suffix str str-len suffix-len )
  2dup i.< if
    # suffix longer than string - can't match
    3drop drop false
  else
    # Get the end of the string
    i.subtract                # ( suffix str offset )
    over string.length      # ( suffix str offset len )
    string.substring        # ( suffix end-of-str )
    string.equal?
  then
;

# Handle GET request for store - get current count
# Stack: ( registry socket path -- registry )
: do-get-store ( Variant Int String -- Variant )
  # Strip leading / if present
  dup 0 string.char-at 47 i.= if  # 47 = '/'
    1 over string.length 1 i.subtract string.substring
  then

  # Look up actor in unified registry
  # Stack: ( registry socket path )
  2 pick swap lookup-store  # ( registry socket chan found? )

  not if
    # Store not found
    drop                    # ( registry socket )
    "Store not found" http-not-found
    over tcp.write
    tcp.close               # ( registry )
  else
    # Send get request to actor and wait for response
    query-actor             # ( registry socket count )
    make-json-response      # ( registry socket response )
    over tcp.write
    tcp.close               # ( registry )
  then
;

# Handle INCREMENT request - increment counter and return new value
# Stack: ( registry socket path -- registry )
: do-increment ( Variant Int String -- Variant )
  # Strip leading / if present
  dup 0 string.char-at 47 i.= if
    1 over string.length 1 i.subtract string.substring
  then

  # Look up store in unified registry
  # Stack: ( registry socket path )
  2 pick swap lookup-store  # ( registry socket chan found? )

  not if
    drop                    # ( registry socket )
    "Store not found" http-not-found
    over tcp.write
    tcp.close               # ( registry )
  else
    # Send increment request to actor and wait for response
    query-actor-increment   # ( registry socket count )
    make-json-response      # ( registry socket response )
    over tcp.write
    tcp.close               # ( registry )
  then
;

# Handle GET request for any actor (company, region, district) aggregate
# Stack: ( registry socket path -- registry )
: do-get-actor ( Variant Int String -- Variant )
  # Strip leading / if present
  dup 0 string.char-at 47 i.= if  # 47 = '/'
    1 over string.length 1 i.subtract string.substring
  then

  # Look up actor in unified registry
  # Stack: ( registry socket path )
  2 pick swap lookup-store  # ( registry socket chan found? )

  not if
    # Actor not found
    drop                    # ( registry socket )
    "Actor not found" http-not-found
    over tcp.write
    tcp.close               # ( registry )
  else
    # Query actor for aggregate
    query-actor             # ( registry socket count )
    make-json-response      # ( registry socket response )
    over tcp.write
    tcp.close               # ( registry )
  then
;

# Query an actor for its current count
# Stack: ( chan-id -- count )
: query-actor ( Int -- Int )
  chan.make              # ( chan-id resp-chan )
  dup Make-Get              # ( chan-id resp-chan msg )
  rot chan.send               # ( resp-chan success )
  not if drop 0 else          # return 0 if send failed
    dup chan.receive          # ( resp-chan value success )
    not if drop drop 0 else   # return 0 if receive failed
      swap chan.close         # ( count ) - close response channel
    then
  then
;

# Query an actor to increment and return new count
# Stack: ( chan-id -- count )
: query-actor-increment ( Int -- Int )
  chan.make              # ( chan-id resp-chan )
  dup Make-Increment        # ( chan-id resp-chan msg )
  rot chan.send               # ( resp-chan success )
  not if drop 0 else          # return 0 if send failed
    dup chan.receive          # ( resp-chan value success )
    not if drop drop 0 else   # return 0 if receive failed
      swap chan.close         # ( count ) - close response channel
    then
  then
;

# Build JSON response from count
# Stack: ( count -- response-string )
: make-json-response ( Int -- String )
  int->string
  "{\"count\":" swap string.concat "}" string.concat
  http-json-ok
;

# Build HTTP 200 OK response with JSON content type
# Stack: ( body -- response )
: http-json-ok ( String -- String )
  dup string.length int->string
  "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: " swap string.concat
  "\r\n\r\n" string.concat
  swap string.concat
;

# ============================================================================
#                            SERVER LOOP
# ============================================================================
#
# CSP-style concurrency: spawn a new strand for each connection.
# The main loop never blocks on request handling - it immediately
# returns to accepting the next connection.

# Connection handler - runs in its own strand
# Stack: ( registry socket -- )
: connection-handler ( Variant Int -- )
  handle-request            # ( registry' )
  drop                      # discard registry (immutable after init)
;

# Accept loop - spawns concurrent handlers
# Stack: ( registry listener -- ) [never returns]
: accept-loop ( Variant Int -- )
  dup tcp.accept            # ( registry listener client )

  # Prepare stack for spawn: child needs ( registry client )
  2 pick                    # ( registry listener client registry )
  swap                      # ( registry listener registry client )

  # Spawn handler - child gets copy of stack, runs connection-handler
  [ connection-handler ] spawn  # child: ( registry listener registry client )
  # connection-handler takes top 2: ( registry client ), handles request

  # Parent cleanup: ( registry listener registry client strand-id )
  3drop            # ( registry listener )

  accept-loop               # immediately accept next connection (TCO)
;

# ============================================================================
#                               MAIN
# ============================================================================

: main ( -- Int )
  "=== Actor Counters Demo (4-Tier Hierarchical Aggregation) ===" io.write-line
  "" io.write-line

  # Initialize the full 4-tier actor hierarchy
  init-four-tier            # ( registry )

  "" io.write-line
  "Starting HTTP server on port 8080..." io.write-line
  "Try:" io.write-line
  "  curl http://localhost:8080/acme/west/seattle/0001           (store)" io.write-line
  "  curl -X POST http://localhost:8080/acme/west/seattle/0001/increment" io.write-line
  "  curl http://localhost:8080/acme/west/seattle                (district)" io.write-line
  "  curl http://localhost:8080/acme/west                        (region)" io.write-line
  "  curl http://localhost:8080/acme                             (company)" io.write-line
  "" io.write-line
  "Aggregation: stores batch (every 5), parents forward immediately" io.write-line
  "  Stores report to district every 5 increments (batching)" io.write-line
  "  Districts/regions/company forward on every update" io.write-line
  "" io.write-line

  # Start listening
  8080 tcp.listen           # ( registry listener )

  dup 0 i.< if
    drop drop
    "Failed to start server" io.write-line
    1
  else
    "Server listening... (concurrent request handling)" io.write-line
    accept-loop             # Never returns - spawns handler per connection
    0
  then
;
