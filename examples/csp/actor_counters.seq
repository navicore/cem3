# Actor Counters - CSP/Actor Model Demo (4-Tier Hierarchical Aggregation)
#
# This example demonstrates Communicating Sequential Processes (CSP) and the
# Actor model in Seq with 4-tier hierarchical aggregation:
#
# Architecture:
#   - Company actor: top-level aggregate, receives reports from regions
#   - Region actors: aggregate reports from districts, forward to company
#   - District actors: aggregate reports from stores, forward to region
#   - Store actors: maintain individual counters, batch reports to district
#   - Unified registry maps paths to channel IDs for all actor levels
#   - Request-response pattern for queries
#   - Fire-and-forget pattern for aggregation reports
#
# Aggregation Pattern:
#   - Stores batch updates: after every 5 increments, report delta to district
#   - Parent levels (district/region/company) forward immediately on each update
#   - This balances message volume reduction with aggregate freshness
#
# URL scheme (RESTful - path depth determines level):
#   GET  /acme/west/seattle/0001           -> store count (4 segments)
#   POST /acme/west/seattle/0001/increment -> increment store
#   GET  /acme/west/seattle                -> district aggregate (3 segments)
#   GET  /acme/west                        -> region aggregate (2 segments)
#   GET  /acme                             -> company aggregate (1 segment)
#
# Usage:
#   seqc --output /tmp/actors examples/csp/actor_counters.seq
#   /tmp/actors
#   curl http://localhost:8080/acme/west/seattle/0001
#   curl -X POST http://localhost:8080/acme/west/seattle/0001/increment
#   curl http://localhost:8080/acme/west/seattle
#   curl http://localhost:8080/acme/west
#   curl http://localhost:8080/acme

include std:http

# ============================================================================
#                              MESSAGE PROTOCOL
# ============================================================================
#
# Type-safe message protocol using ADTs:
#   - Get: request current count, includes response channel
#   - Increment: increment counter, includes response channel
#   - Report: fire-and-forget aggregation report (delta + total)
#
# Responses are single Int values (the count)

union Message {
  Get { response_chan: Int }
  Increment { response_chan: Int }
  Report { delta: Int, total: Int }
}

# Report threshold - send to parent every N increments
: report-threshold ( -- Int )
  5
;

# ============================================================================
#                              STORE ACTOR
# ============================================================================
#
# Each store is an actor that:
#   1. Receives messages on its channel
#   2. Maintains a counter through recursion (TCO)
#   3. Responds on the caller's response channel
#   4. Reports to parent (district) every N increments
#
# State maintained via recursion:
#   - count: current counter value
#   - pending: changes since last report to parent
#
# The actor runs forever via tail-recursive loop.

# Store actor entry point
# Receives ( my-chan parent-chan ) via spawn's stack cloning
: store-actor ( Int Int -- )
  swap                       # ( parent-chan my-chan )
  0 0 store-loop             # Start with count=0, pending=0
;

# Store actor main loop - handles messages forever
# Stack: ( parent-chan my-chan count pending -- ) [never returns]
: store-loop ( Int Int Int Int -- )
  # Receive on my-chan (which is at depth 2)
  2 pick receive             # ( parent my count pending msg )

  match
    Get { response_chan } ->
      # Return current count on response channel
      # Stack: ( parent my count pending response_chan )
      2 pick swap send       # ( parent my count pending )
      store-loop

    Increment { response_chan } ->
      # Increment counter and return new count
      # Stack: ( parent my count pending response_chan )
      rot 1 add              # ( parent my pending response_chan count+1 )
      dup rot send           # ( parent my pending count+1 ) - sent response
      swap 1 add             # ( parent my count+1 pending+1 )

      # Check if we should report to parent
      dup report-threshold >= if
        # Time to report! Send delta to parent
        dup                  # ( parent my count pending pending )
        2 pick               # ( parent my count pending pending count )
        Make-Report          # ( parent my count pending report-msg )
        4 pick send          # ( parent my count pending ) - sent to parent
        drop 0               # ( parent my count 0 ) - reset pending
      then
      store-loop

    Report ->
      # Stores don't receive Report messages - ignore
      # Stack: ( parent my count pending delta total )
      drop drop              # ( parent my count pending )
      store-loop
  end
;

# ============================================================================
#                            DISTRICT ACTOR
# ============================================================================
#
# District actor aggregates reports from stores and forwards immediately.
#   - Receives REPORT messages from stores (op=2)
#   - Receives GET messages from HTTP clients (op=0)
#   - Maintains aggregate total across all stores
#   - Forwards to region immediately on every update

# District actor entry point
# Receives ( my-chan parent-chan ) via spawn's stack cloning
: district-actor ( Int Int -- )
  swap                       # ( parent-chan my-chan )
  0 district-loop            # Start with total=0
;

# District actor main loop - simple: aggregate and forward immediately
# Stack: ( parent-chan my-chan total -- ) [never returns]
: district-loop ( Int Int Int -- )
  over receive               # ( parent my total msg )

  match
    Get { response_chan } ->
      # Return aggregate total on response channel
      # Stack: ( parent my total response_chan )
      over swap send         # ( parent my total ) - sent total
      district-loop

    Report { delta } ->
      # Add delta, forward to region immediately
      # Stack: ( parent my total delta )
      dup rot add            # ( parent my delta total+delta )
      swap                   # ( parent my total' delta )
      over                   # ( parent my total' delta total' )
      Make-Report            # ( parent my total' report-msg )
      3 pick send            # ( parent my total' ) - forwarded to region
      district-loop

    Increment ->
      # Districts don't handle Increment - ignore
      # Stack: ( parent my total response_chan )
      drop                   # ( parent my total )
      district-loop
  end
;

# ============================================================================
#                            REGION ACTOR
# ============================================================================
#
# Region actor aggregates reports from districts.
#   - Receives REPORT messages from districts (op=2)
#   - Receives GET messages from HTTP clients (op=0)
#   - Forwards to company immediately on every update

# Region actor entry point
: region-actor ( Int Int -- )
  swap                       # ( parent-chan my-chan )
  0 region-loop              # Start with total=0
;

# Region actor main loop - simple: aggregate and forward immediately
# Stack: ( parent-chan my-chan total -- ) [never returns]
: region-loop ( Int Int Int -- )
  over receive               # ( parent my total msg )

  match
    Get { response_chan } ->
      # Return aggregate total on response channel
      # Stack: ( parent my total response_chan )
      over swap send         # ( parent my total )
      region-loop

    Report { delta } ->
      # Add delta, forward to company immediately
      # Stack: ( parent my total delta )
      dup rot add            # ( parent my delta total+delta )
      swap                   # ( parent my total' delta )
      over                   # ( parent my total' delta total' )
      Make-Report            # ( parent my total' report-msg )
      3 pick send            # ( parent my total' ) - forwarded to company
      region-loop

    Increment ->
      # Regions don't handle Increment - ignore
      # Stack: ( parent my total response_chan )
      drop                   # ( parent my total )
      region-loop
  end
;

# ============================================================================
#                            COMPANY ACTOR
# ============================================================================
#
# Company actor aggregates reports from regions.
#   - Top of hierarchy - no parent to report to
#   - Receives REPORT messages from regions (op=2)
#   - Receives GET messages from HTTP clients (op=0)

# Company actor entry point
: company-actor ( Int -- )
  0 company-loop
;

# Company actor main loop
# Stack: ( my-chan total -- ) [never returns]
: company-loop ( Int Int -- )
  over receive               # ( my-chan total msg )

  match
    Get { response_chan } ->
      # Return aggregate total on response channel
      # Stack: ( my-chan total response_chan )
      over swap send         # ( my-chan total )
      company-loop

    Report { delta } ->
      # Add delta (no forwarding - company is top of hierarchy)
      # Stack: ( my-chan total delta )
      add                    # ( my-chan total+delta )
      company-loop

    Increment ->
      # Company doesn't handle Increment - ignore
      # Stack: ( my-chan total response_chan )
      drop                   # ( my-chan total )
      company-loop
  end
;

# ============================================================================
#                              REGISTRIES
# ============================================================================
#
# Four registries (one per hierarchy level):
#   - Company registry: "acme" -> company channel
#   - Region registry: "acme/west" -> region channel
#   - District registry: "acme/west/seattle" -> district channel
#   - Store registry: "acme/west/seattle/0001" -> store channel

# Create an empty registry
# Stack: ( -- registry )
: make-registry ( -- Variant )
  make-map
;

# Look up in a registry
# Stack: ( registry path -- channel-id found? )
: lookup-store ( Variant String -- Int Int )
  map-get-safe   # ( value found? )
;

# Create a company actor and register it
# Stack: ( company-registry company-name -- company-registry' company-chan )
: create-company ( Variant String -- Variant Int )
  make-channel               # ( registry name chan )
  dup                        # ( registry name chan chan )
  [ company-actor ] spawn    # ( registry name chan chan strand-id )
  drop drop                  # ( registry name chan )

  dup                        # ( registry name chan chan )
  3 roll                     # ( name chan chan registry )
  3 roll                     # ( chan chan registry name )
  3 roll                     # ( chan registry name chan )
  map-set                    # ( chan registry' )
  swap                       # ( registry' chan )
;

# Create a region actor and register it
# Stack: ( parent-chan region-registry region-path -- region-registry' region-chan )
: create-region ( Int Variant String -- Variant Int )
  make-channel               # ( parent registry path chan )
  dup                        # ( parent registry path chan chan )
  4 pick                     # ( parent registry path chan chan parent )
  [ region-actor ] spawn     # ( parent registry path chan chan parent strand-id )
  drop drop drop             # ( parent registry path chan )

  dup                        # ( parent registry path chan chan )
  3 roll                     # ( parent path chan chan registry )
  3 roll                     # ( parent chan chan registry path )
  3 roll                     # ( parent chan registry path chan )
  map-set                    # ( parent chan registry' )
  swap                       # ( parent registry' chan )
  rot drop                   # ( registry' chan )
;

# Create a district actor and register it
# Stack: ( parent-chan district-registry district-path -- district-registry' district-chan )
: create-district ( Int Variant String -- Variant Int )
  make-channel               # ( parent registry path chan )
  dup                        # ( parent registry path chan chan )
  4 pick                     # ( parent registry path chan chan parent )
  [ district-actor ] spawn   # ( parent registry path chan chan parent strand-id )
  drop drop drop             # ( parent registry path chan )

  dup                        # ( parent registry path chan chan )
  3 roll                     # ( parent path chan chan registry )
  3 roll                     # ( parent chan chan registry path )
  3 roll                     # ( parent chan registry path chan )
  map-set                    # ( parent chan registry' )
  swap                       # ( parent registry' chan )
  rot drop                   # ( registry' chan )
;

# ============================================================================
#                          STORE GENERATION
# ============================================================================
#
# Generate a hierarchical set of stores:
#   companies × regions × districts × stores
#
# Each store gets a unique path like "acme/west/seattle/0042"

# Pad a string with leading zeros
# Stack: ( str count -- padded-str )
: pad-zeros ( String Int -- String )
  dup 0 <= if
    drop
  else
    "0" rot string-concat swap
    1 subtract pad-zeros
  then
;

# Pad a string to a minimum width with leading zeros
# Stack: ( str width -- padded-str )
: pad-to-width ( String Int -- String )
  over string-length        # ( str width len )
  over swap subtract        # ( str width padding )
  nip                       # ( str padding )
  pad-zeros                 # ( padded-str )
;

# Build a store path from components
# Stack: ( company region district store-num -- path )
: build-path ( String String String Int -- String )
  int->string               # ( company region district store-str )
  # Pad store number to 4 digits (e.g., 1 -> "0001")
  4 pad-to-width            # ( company region district padded-store )

  # Stack: ( company region district store )
  # Build: company/region/district/store

  # Join district "/" store -> "district/store"
  swap "/" string-concat    # ( company region store "district/" )
  swap string-concat        # ( company region "district/store" )

  # Join region "/" ... -> "region/district/store"
  swap "/" string-concat    # ( company "district/store" "region/" )
  swap string-concat        # ( company "region/district/store" )

  # Join company "/" ... -> "company/region/district/store"
  swap "/" string-concat    # ( "region/district/store" "company/" )
  swap string-concat        # ( "company/region/district/store" )
;

# Create a single store with parent channel
# Stack: ( parent-chan path registry -- registry' )
: create-store ( Int String Variant -- Variant )
  make-channel               # ( parent path registry chan )

  # Spawn the store actor: needs ( my-chan parent-chan ) on stack
  dup                        # ( parent path registry chan chan )
  4 pick                     # ( parent path registry chan chan parent )
  [ store-actor ] spawn      # ( parent path registry chan chan parent strand-id )
  drop drop drop             # ( parent path registry chan )

  # Now: ( parent path registry chan )
  # Need: ( registry path chan ) for map-set

  # rot on top 3 ( path registry chan ) -> ( registry chan path )
  rot                        # ( parent registry chan path )

  # 3 roll brings parent to top
  3 roll                     # ( registry chan path parent )
  drop                       # ( registry chan path )

  # Now we have ( registry chan path )
  # Need ( registry path chan )
  # swap swaps top 2: ( registry path chan )
  swap                       # ( registry path chan )
  map-set                    # ( registry' )
;

# Number of stores per district
: stores-per-district ( -- Int )
  10   # Start with 10 stores per district for testing
;

# ============================================================================
#                         HIERARCHY GENERATION
# ============================================================================
#
# 4-tier actor hierarchy using a SINGLE flat registry:
#   - "acme" -> company actor channel
#   - "acme/west" -> region actor channel
#   - "acme/west/seattle" -> district actor channel
#   - "acme/west/seattle/0001" -> store actor channel
#
# This simplifies stack management - one registry holds all levels.
# Path segment count determines level (1=company, 2=region, 3=district, 4=store).

# Helper: Generate stores for a district (recursive)
# Stack: ( parent-chan prefix counter registry -- registry' )
: gen-stores-loop ( Int String Int Variant -- Variant )
  over 0 <= if
    nip nip nip
  else
    over int->string 4 pad-to-width
    3 pick swap string-concat      # ( parent prefix counter registry path )
    over 5 pick rot rot            # ( parent prefix counter registry parent path registry )
    create-store                   # ( parent prefix counter registry new-reg )
    nip swap 1 subtract swap       # ( parent prefix counter-1 new-reg )
    gen-stores-loop
  then
;

# Create stores for a district
# Stack: ( registry district-chan district-path -- registry' )
: add-stores ( Variant Int String -- Variant )
  "/" string-concat                # ( registry district-chan prefix )
  stores-per-district              # ( registry district-chan prefix count )
  rot                              # ( registry prefix count district-chan )
  rot rot                          # ( registry district-chan prefix count )
  3 roll                           # ( district-chan prefix count registry )
  gen-stores-loop                  # ( registry' )
;


# Build 4-tier hierarchy with single unified registry
# Stack: ( -- registry )
: init-four-tier ( -- Variant )
  make-registry
  "Initializing 4-tier actor hierarchy..." write_line

  # === ACME COMPANY ===
  "acme" create-company           # ( registry acme-chan )

  # === ACME/WEST REGION ===
  swap "acme/west" create-region  # ( registry west-chan )

  # === ACME/WEST/SEATTLE DISTRICT ===
  swap "acme/west/seattle" create-district  # ( registry seattle-chan )
  "acme/west/seattle" add-stores  # ( registry )

  # === ACME/WEST/PORTLAND DISTRICT ===
  # Need to look up west-chan again
  dup "acme/west" lookup-store drop  # ( registry west-chan )
  swap "acme/west/portland" create-district  # ( registry portland-chan )
  "acme/west/portland" add-stores  # ( registry )

  # === ACME/EAST REGION ===
  dup "acme" lookup-store drop    # ( registry acme-chan )
  swap "acme/east" create-region  # ( registry east-chan )

  # === ACME/EAST/BOSTON DISTRICT ===
  swap "acme/east/boston" create-district  # ( registry boston-chan )
  "acme/east/boston" add-stores   # ( registry )

  # === ACME/EAST/NEWYORK DISTRICT ===
  dup "acme/east" lookup-store drop  # ( registry east-chan )
  swap "acme/east/newyork" create-district  # ( registry newyork-chan )
  "acme/east/newyork" add-stores  # ( registry )

  # Print summary
  "  Company: acme" write_line
  "  Regions: acme/west, acme/east" write_line
  "  Districts: seattle, portland, boston, newyork" write_line
  dup map-size int->string " actors in unified registry" string-concat write_line
;



# ============================================================================
#                            HTTP HANDLING
# ============================================================================
#
# RESTful routes - path depth determines resource level:
#   GET  /acme/west/seattle/0001           -> store (4 segments)
#   POST /acme/west/seattle/0001/increment -> increment store
#   GET  /acme/west/seattle                -> district aggregate (3 segments)
#   GET  /acme/west                        -> region aggregate (2 segments)
#   GET  /acme                             -> company aggregate (1 segment)

# Count path segments (splits on "/" and counts non-empty parts)
# Stack: ( path -- count )
: count-path-segments ( String -- Int )
  # Strip leading / if present
  dup 0 string-char-at 47 = if  # 47 = '/'
    1 over string-length 1 subtract string-substring
  then
  "/" string-split variant-field-count
;

# Handle an HTTP request
# Stack: ( registry socket -- registry )
: handle-request ( Variant Int -- Variant )
  # Read the HTTP request
  dup tcp-read               # ( registry socket request )

  # Extract path from request
  dup http-request-path      # ( registry socket request path )
  swap http-request-method   # ( registry socket path method )

  # Dispatch based on path
  dispatch-request
;

# Dispatch request to appropriate handler
# Stack: ( registry socket path method -- registry )
: dispatch-request ( Variant Int String String -- Variant )
  # Check if path ends with /increment
  over "/increment" string-ends-with? if
    # Increment request - strip suffix and do increment
    drop                     # ( registry socket path )
    dup string-length 10 subtract 0 swap string-substring  # remove "/increment"
    do-increment
  else
    drop                     # ( registry socket path )
    # Count segments to determine resource level
    dup count-path-segments  # ( registry socket path segments )
    dup 4 = if
      # 4 segments = store query
      drop do-get-store
    else
      dup 3 = if
        # 3 segments = district aggregate
        drop do-get-actor
      else
        dup 2 = if
          # 2 segments = region aggregate
          drop do-get-actor
        else
          dup 1 = if
            # 1 segment = company aggregate
            drop do-get-actor
          else
            # Unknown - return 404
            drop drop
            "Not found - use 1-4 segments: company/region/district/store" http-not-found
            over tcp-write
            tcp-close
          then
        then
      then
    then
  then
;

# Check if string ends with suffix
# Stack: ( str suffix -- bool )
: string-ends-with? ( String String -- Int )
  dup string-length         # ( str suffix suffix-len )
  rot dup string-length     # ( suffix suffix-len str str-len )
  rot                       # ( suffix str str-len suffix-len )
  over over < if
    # suffix longer than string - can't match
    drop drop drop drop 0
  else
    # Get the end of the string
    subtract                # ( suffix str offset )
    over string-length      # ( suffix str offset len )
    string-substring        # ( suffix end-of-str )
    string-equal
  then
;

# Handle GET request for store - get current count
# Stack: ( registry socket path -- registry )
: do-get-store ( Variant Int String -- Variant )
  # Strip leading / if present
  dup 0 string-char-at 47 = if  # 47 = '/'
    1 over string-length 1 subtract string-substring
  then

  # Look up actor in unified registry
  # Stack: ( registry socket path )
  2 pick swap lookup-store  # ( registry socket chan found? )

  0 = if
    # Store not found
    drop                    # ( registry socket )
    "Store not found" http-not-found
    over tcp-write
    tcp-close               # ( registry )
  else
    # Send get request to actor and wait for response
    query-actor             # ( registry socket count )
    make-json-response      # ( registry socket response )
    over tcp-write
    tcp-close               # ( registry )
  then
;

# Handle INCREMENT request - increment counter and return new value
# Stack: ( registry socket path -- registry )
: do-increment ( Variant Int String -- Variant )
  # Strip leading / if present
  dup 0 string-char-at 47 = if
    1 over string-length 1 subtract string-substring
  then

  # Look up store in unified registry
  # Stack: ( registry socket path )
  2 pick swap lookup-store  # ( registry socket chan found? )

  0 = if
    drop                    # ( registry socket )
    "Store not found" http-not-found
    over tcp-write
    tcp-close               # ( registry )
  else
    # Send increment request to actor and wait for response
    query-actor-increment   # ( registry socket count )
    make-json-response      # ( registry socket response )
    over tcp-write
    tcp-close               # ( registry )
  then
;

# Handle GET request for any actor (company, region, district) aggregate
# Stack: ( registry socket path -- registry )
: do-get-actor ( Variant Int String -- Variant )
  # Strip leading / if present
  dup 0 string-char-at 47 = if  # 47 = '/'
    1 over string-length 1 subtract string-substring
  then

  # Look up actor in unified registry
  # Stack: ( registry socket path )
  2 pick swap lookup-store  # ( registry socket chan found? )

  0 = if
    # Actor not found
    drop                    # ( registry socket )
    "Actor not found" http-not-found
    over tcp-write
    tcp-close               # ( registry )
  else
    # Query actor for aggregate
    query-actor             # ( registry socket count )
    make-json-response      # ( registry socket response )
    over tcp-write
    tcp-close               # ( registry )
  then
;

# Query an actor for its current count
# Stack: ( chan-id -- count )
: query-actor ( Int -- Int )
  make-channel              # ( chan-id resp-chan )
  dup Make-Get              # ( chan-id resp-chan msg )
  rot send                  # ( resp-chan ) - sent msg to actor
  receive                   # ( count )
;

# Query an actor to increment and return new count
# Stack: ( chan-id -- count )
: query-actor-increment ( Int -- Int )
  make-channel              # ( chan-id resp-chan )
  dup Make-Increment        # ( chan-id resp-chan msg )
  rot send                  # ( resp-chan ) - sent msg to actor
  receive                   # ( count )
;

# Build JSON response from count
# Stack: ( count -- response-string )
: make-json-response ( Int -- String )
  int->string
  "{\"count\":" swap string-concat "}" string-concat
  http-json-ok
;

# Build HTTP 200 OK response with JSON content type
# Stack: ( body -- response )
: http-json-ok ( String -- String )
  dup string-length int->string
  "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nContent-Length: " swap string-concat
  "\r\n\r\n" string-concat
  swap string-concat
;

# ============================================================================
#                            SERVER LOOP
# ============================================================================
#
# CSP-style concurrency: spawn a new strand for each connection.
# The main loop never blocks on request handling - it immediately
# returns to accepting the next connection.

# Connection handler - runs in its own strand
# Stack: ( registry socket -- )
: connection-handler ( Variant Int -- )
  handle-request            # ( registry' )
  drop                      # discard registry (immutable after init)
;

# Accept loop - spawns concurrent handlers
# Stack: ( registry listener -- ) [never returns]
: accept-loop ( Variant Int -- )
  dup tcp-accept            # ( registry listener client )

  # Prepare stack for spawn: child needs ( registry client )
  2 pick                    # ( registry listener client registry )
  swap                      # ( registry listener registry client )

  # Spawn handler - child gets copy of stack, runs connection-handler
  [ connection-handler ] spawn  # child: ( registry listener registry client )
  # connection-handler takes top 2: ( registry client ), handles request

  # Parent cleanup: ( registry listener registry client strand-id )
  drop drop drop            # ( registry listener )

  accept-loop               # immediately accept next connection (TCO)
;

# ============================================================================
#                               MAIN
# ============================================================================

: main ( -- Int )
  "=== Actor Counters Demo (4-Tier Hierarchical Aggregation) ===" write_line
  "" write_line

  # Initialize the full 4-tier actor hierarchy
  init-four-tier            # ( registry )

  "" write_line
  "Starting HTTP server on port 8080..." write_line
  "Try:" write_line
  "  curl http://localhost:8080/acme/west/seattle/0001           (store)" write_line
  "  curl -X POST http://localhost:8080/acme/west/seattle/0001/increment" write_line
  "  curl http://localhost:8080/acme/west/seattle                (district)" write_line
  "  curl http://localhost:8080/acme/west                        (region)" write_line
  "  curl http://localhost:8080/acme                             (company)" write_line
  "" write_line
  "Aggregation: stores batch (every 5), parents forward immediately" write_line
  "  Stores report to district every 5 increments (batching)" write_line
  "  Districts/regions/company forward on every update" write_line
  "" write_line

  # Start listening
  8080 tcp-listen           # ( registry listener )

  dup 0 < if
    drop drop
    "Failed to start server" write_line
    1
  else
    "Server listening... (concurrent request handling)" write_line
    accept-loop             # Never returns - spawns handler per connection
    0
  then
;
