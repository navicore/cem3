# ============================================================================
#                    CONCATENATIVE PROGRAMMING TUTORIAL
#                        A Working HTTP Server in Seq
# ============================================================================
#
# This file is both a working HTTP server AND a tutorial on concatenative
# (stack-based) programming. If you're new to this paradigm, read on!
#
# ============================================================================
#                         WHAT IS CONCATENATIVE PROGRAMMING?
# ============================================================================
#
# In most languages, you write expressions like:  result = add(multiply(x, 2), 1)
#
# In concatenative languages, there are no variables or parentheses.
# Instead, all data lives on a STACK, and every operation:
#   1. Takes values FROM the top of the stack
#   2. Puts results BACK onto the stack
#
# The equivalent in Seq would be:  x 2 i.multiply 1 i.add
#
# Reading left to right:
#   x          -- push x onto stack
#   2          -- push 2 onto stack
#   i.multiply -- pop two values, multiply them, push result
#   1          -- push 1 onto stack
#   i.add      -- pop two values, add them, push result
#
# ============================================================================
#                              THE STACK
# ============================================================================
#
# Think of the stack as a pile of plates. You can only:
#   - Put a plate on TOP (push)
#   - Take a plate from TOP (pop)
#
# We write stack state in parentheses, with the TOP on the right:
#   ( bottom middle top )
#
# Example trace:
#   Operation     Stack after
#   ---------     -----------
#   5             ( 5 )
#   3             ( 5 3 )
#   i.add         ( 8 )         -- i.add pops 5 and 3, pushes 8
#   2             ( 8 2 )
#   i.multiply    ( 16 )        -- i.multiply pops 8 and 2, pushes 16
#
# ============================================================================
#                         STACK EFFECT NOTATION
# ============================================================================
#
# Every word (function) has a "stack effect" showing what it consumes and
# produces. We write this as: ( inputs -- outputs )
#
# Examples:
#   i.add      ( a b -- sum )         Takes 2, produces 1
#   dup        ( a -- a a )           Takes 1, produces 2 (duplicates)
#   drop       ( a -- )               Takes 1, produces 0 (discards)
#   swap       ( a b -- b a )         Takes 2, produces 2 (reorders)
#
# The "--" separates "what I consume" from "what I produce".
#
# ============================================================================
#                      CORE STACK OPERATIONS
# ============================================================================
#
# These are your fundamental tools for manipulating the stack:
#
#   dup   ( a -- a a )         Duplicate the top value
#         Example: ( 5 )  ->  ( 5 5 )
#
#   drop  ( a -- )             Discard the top value
#         Example: ( 5 3 )  ->  ( 5 )
#
#   swap  ( a b -- b a )       Swap top two values
#         Example: ( 5 3 )  ->  ( 3 5 )
#
#   over  ( a b -- a b a )     Copy second item to top
#         Example: ( 5 3 )  ->  ( 5 3 5 )
#
#   rot   ( a b c -- b c a )   Rotate third item to top
#         Example: ( 1 2 3 )  ->  ( 2 3 1 )
#
#   nip   ( a b -- b )         Drop second item (keep top)
#         Example: ( 5 3 )  ->  ( 3 )
#
# ============================================================================
#                       DEFINING WORDS (FUNCTIONS)
# ============================================================================
#
# A "word" is a named sequence of operations. Define with colon, end with
# semicolon:
#
#   : word-name ( stack-effect )
#     operations here
#   ;
#
# Example - a word that squares a number:
#
#   : square ( n -- n*n )
#     dup i.multiply
#   ;
#
# Trace of "5 square":
#   5           ( 5 )
#   square ->
#     dup        ( 5 5 )
#     i.multiply ( 25 )
#
# ============================================================================
#                    NOW LET'S BUILD AN HTTP SERVER!
# ============================================================================
#
# We'll start with helper functions, building up to the full server.
# Each function includes detailed stack traces so you can follow along.
#

# ============================================================================
# HELPER: Build HTTP 200 OK Response
# ============================================================================
#
# This word takes a body string and wraps it in a valid HTTP response.
#
# Stack effect: ( body -- response )
#
# Why is this tricky? We need to:
#   1. Keep the body (we'll need it at the end)
#   2. Calculate its length for Content-Length header
#   3. Build the header string
#   4. Concatenate header + body
#
# Let's trace through with body = "Hello":
#
: http-ok ( String -- String )
  # Stack: ( "Hello" )

  dup string.length int->string
  # dup:           ( "Hello" "Hello" )      -- make a copy
  # string.length: ( "Hello" 5 )            -- length of the copy
  # int->string:   ( "Hello" "5" )          -- convert to string

  "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: " swap string.concat
  # push string:   ( "Hello" "5" "HTTP...Length: " )
  # swap:          ( "Hello" "HTTP...Length: " "5" )
  # string.concat: ( "Hello" "HTTP...Length: 5" )

  "\r\n\r\n" string.concat
  # push string:   ( "Hello" "HTTP...Length: 5" "\r\n\r\n" )
  # string.concat: ( "Hello" "HTTP...Length: 5\r\n\r\n" )

  swap string.concat
  # swap:          ( "HTTP...Length: 5\r\n\r\n" "Hello" )
  # string.concat: ( "HTTP...Length: 5\r\n\r\nHello" )

  # Final result: complete HTTP response with correct Content-Length!
;

# ============================================================================
# HELPER: Build HTTP 404 Not Found Response
# ============================================================================
#
# Same pattern as http-ok, just different status line.
#
: http-not-found ( String -- String )
  dup string.length int->string
  "HTTP/1.1 404 Not Found\r\nContent-Type: text/plain\r\nContent-Length: " swap string.concat
  "\r\n\r\n" string.concat
  swap string.concat
;

# ============================================================================
# HELPER: Extract Request Line
# ============================================================================
#
# HTTP requests look like:
#   "GET /path HTTP/1.1\r\nHost: ...\r\n\r\n"
#
# We want just the first line: "GET /path HTTP/1.1"
#
# string.split returns a Variant (like an array). We get field 0.
#
: http-request-line ( String -- String )
  "\r\n" string.split     # Split on line ending -> Variant
  0 variant.field-at      # Get first field (index 0)
;

# ============================================================================
# HELPER: Extract Request Path
# ============================================================================
#
# From "GET /path HTTP/1.1", extract "/path" (the middle part).
#
# We split on space and get field 1 (second element).
#
: http-request-path ( String -- String )
  http-request-line       # "GET /path HTTP/1.1"
  " " string.split        # Split on space -> Variant["GET", "/path", "HTTP/1.1"]
  1 variant.field-at      # Get field 1 -> "/path"
;

# ============================================================================
# HELPER: Extract Request Method
# ============================================================================
#
# From "GET /path HTTP/1.1", extract "GET" (the first part).
#
: http-request-method ( String -- String )
  http-request-line
  " " string.split
  0 variant.field-at      # Get field 0 -> "GET"
;

# ============================================================================
# HELPER: Extract Suffix After Prefix
# ============================================================================
#
# Given "/echo/hello" and prefix "/echo/", return "hello".
#
# This is more complex because we need to handle the case where the string
# doesn't start with the prefix.
#
# Stack effect: ( str prefix -- suffix )
#
# Key insight: We use "2dup" to make copies for the check, keeping
# originals for the actual split.
#
: string-suffix-after ( String String -- String )
  # Stack: ( str prefix )
  # Example: ( "/echo/hello" "/echo/" )

  2dup string.starts-with if
    # "2dup" copied both values for the check:
    #   over:              ( str prefix str )
    #   over:              ( str prefix str prefix )
    #   string.starts-with: ( str prefix 1 )  -- true!
    # The "if" consumed the 1, leaving: ( str prefix )

    string.split
    # Split "/echo/hello" on "/echo/" gives: Variant["", "hello"]
    # Stack: ( variant )

    dup variant.field-count 2 i.< if
      # Edge case: not enough parts (shouldn't happen if starts-with was true)
      drop ""
    else
      1 variant.field-at
      # Get field 1 -> "hello"
    then
  else
    # Doesn't start with prefix - return empty string
    drop drop ""
  then
;

# ============================================================================
# HELPER: Extract Path Suffix
# ============================================================================
#
# Combines path extraction with suffix extraction.
#
# From full HTTP request and a prefix like "/echo/", get what comes after.
#
# Example:
#   "GET /echo/hello HTTP/1.1\r\n..." and "/echo/"
#   -> extracts path "/echo/hello", then suffix "hello"
#
: http-path-suffix ( String String -- String )
  # Stack: ( request prefix )
  # Example: ( "GET /echo/hello..." "/echo/" )

  swap http-request-path
  # swap:             ( "/echo/" "GET /echo/hello..." )
  # http-request-path: ( "/echo/" "/echo/hello" )

  swap string-suffix-after
  # swap:              ( "/echo/hello" "/echo/" )
  # string-suffix-after: ( "hello" )
;

# ============================================================================
#                           THE ROUTER
# ============================================================================
#
# This is the heart of our HTTP server. It examines the request and decides
# what response to send.
#
# IMPORTANT PATTERN: Notice how each branch starts with "dup" to make a copy
# for checking, then uses "drop" to discard the original once we're done
# with it. This is idiomatic concatenative style for conditional dispatch.
#
# Stack effect: ( request -- response )
#
: route ( String -- String )
  # Stack: ( request )

  # ----- Check for root path "/" -----
  dup "GET / " string.starts-with if
    # dup made a copy:        ( request request )
    # string.starts-with:     ( request 1_or_0 )
    # if consumed the flag:   ( request )
    # We matched! Drop the request and return welcome message.
    drop "Welcome to Seq HTTP Server!" http-ok
  else
    # ----- Check for /health endpoint -----
    dup "GET /health" string.starts-with if
      drop "OK" http-ok
    else
      # ----- Check for /echo endpoint -----
      # This is the interesting one - we extract dynamic content!
      dup "GET /echo/" string.starts-with if
        # Stack: ( request )

        "/echo/" http-path-suffix
        # Extracts what comes after "/echo/" in the URL
        # Stack: ( user_input )
        # If URL was /echo/hello-world, this is "hello-world"

        "You said: " swap string.concat
        # push:        ( user_input "You said: " )
        # swap:        ( "You said: " user_input )
        # string.concat: ( "You said: hello-world" )

        http-ok
        # Wrap in HTTP response with headers
      else
        # ----- No route matched: 404 -----
        drop "404 Not Found" http-not-found
      then
    then
  then
;

# ============================================================================
#                      HANDLING CONNECTIONS
# ============================================================================
#
# When a client connects, we need to:
#   1. Read their request
#   2. Route it to get a response
#   3. Write the response back
#   4. Close the connection
#
# The tricky part: we need the socket for BOTH reading AND writing, but
# each operation consumes it. Solution: use "dup" and "over" to keep copies.
#
# Stack effect: ( socket -- )
#
: handle-connection ( Int -- )
  # Stack: ( socket )

  dup                      # ( socket socket )
  # We need the socket twice: once for read, once for write.
  # dup gives us a copy.

  tcp.read                 # ( socket request_string )
  # Read from the copy. Original socket still there!

  route                    # ( socket response_string )
  # Transform request into response.

  over                     # ( socket response_string socket )
  # We need the socket on top to write to it.
  # "over" copies the second item to the top.

  tcp.write                # ( socket )
  # Write response. tcp.write consumes both response and socket,
  # but we still have our original socket underneath!

  tcp.close                # ( )
  # Clean up by closing the connection.
;

# ============================================================================
#                         CONCURRENCY MODEL
# ============================================================================
#
# Seq uses "strands" (lightweight green threads) for concurrency, similar
# to Erlang processes or Go goroutines.
#
# Communication happens through channels (CSP style):
#   - chan.make: creates a new channel, returns channel_id
#   - send: sends a value through a channel
#   - receive: blocks until a value arrives
#
# This is the Actor model: isolated workers communicating via messages.
#

# Worker strand: waits for a socket, then handles it
#
# Stack effect: ( channel -- )
#
: worker ( Channel -- )
  chan.receive                  # Block until we get a socket from the channel (returns value, success)
  if                            # Check success flag
    handle-connection           # Process the request if successful
  else
    drop                        # Drop placeholder value on failure
  then
;

# ============================================================================
#                          THE ACCEPT LOOP
# ============================================================================
#
# This runs forever, accepting connections and spawning workers.
#
# TAIL CALL OPTIMIZATION: The recursive call to accept-loop at the end is
# in tail position - the compiler converts it to a jump, so the stack never
# grows. This is how Seq handles infinite loops: recursion + TCO.
#
# Stack effect: ( listener_socket -- )
# Note: This never returns - it loops forever via tail recursion.
#
: accept-loop ( Int -- )
  # Stack: ( listener_socket )

  dup tcp.accept
  # dup:        ( listener_socket listener_socket )
  # tcp.accept: ( listener_socket client_socket )
  # We keep the listener to accept more connections!

  chan.make
  # Creates a channel for sending the socket to the worker
  # Stack: ( listener_socket client_socket channel_id )

  dup [ worker ] strand.spawn
  # dup:    ( listener_socket client_socket channel_id channel_id )
  # [ worker ]: Push the worker quotation
  # strand.spawn: Start a new strand running "worker" with channel_id, passes stack to child
  # Stack: ( listener_socket client_socket channel_id channel_id strand_id )

  drop drop
  # We don't need the strand_id, and strand.spawn leaves the extra dup'd channel
  # Stack: ( listener_socket client_socket channel_id )

  chan.send
  # Send client_socket through the channel to the worker
  # Stack: ( listener_socket success )
  not if "Failed to send socket to worker" io.write-line then
  # The worker receives the socket and handles the connection!

  accept-loop
  # Tail call - TCO converts this to a jump, no stack growth
;

# ============================================================================
#                            MAIN ENTRY POINT
# ============================================================================
#
# Every Seq program needs a "main" word. This starts the server.
#
# Stack effect: ( -- )
# This server runs forever via tail recursion, never returning.
#
: main ( -- )
  # Print startup messages
  "Starting concurrent HTTP server on port 8080..." io.write-line
  "Try: curl http://localhost:8080/" io.write-line
  "Try: curl http://localhost:8080/health" io.write-line
  "Try: curl http://localhost:8080/echo/hello-world" io.write-line
  "Try: curl http://localhost:8080/echo/anything-you-want" io.write-line
  "Server will handle multiple concurrent connections." io.write-line
  "" io.write-line

  8080 tcp.listen
  # Push port number, call tcp.listen
  # Returns a listener socket on the stack

  "Listening..." io.write-line

  accept-loop
  # Enters infinite loop via tail recursion - never returns
;

# ============================================================================
#                         EXERCISES FOR THE READER
# ============================================================================
#
# 1. TRACE IT: Work through "3 4 i.add 2 i.multiply" by hand:
#      - Write the stack after each operation
#      - What's the final result?
#
# 2. WRITE A WORD: Define "double" that doubles a number:
#      : double ( n -- n*2 )
#        ???
#      ;
#    Hint: You can use "dup i.add" or "2 i.multiply"
#
# 3. ADD A ROUTE: Add a "/time" endpoint that returns a static message.
#    Look at how /health works for the pattern.
#
# 4. STACK DEBUGGING: If you see "stack underflow" errors, trace through
#    your code operation by operation. Common mistakes:
#      - Forgetting to "dup" before an operation that consumes
#      - Off-by-one in which stack position you're accessing
#      - Forgetting to "drop" values you're done with
#
# ============================================================================
#                              KEY TAKEAWAYS
# ============================================================================
#
# 1. DATA FLOWS THROUGH THE STACK - no variables needed
# 2. EVERY WORD HAS A STACK EFFECT - know what goes in and out
# 3. DUP BEFORE YOU CONSUME - if you need a value twice
# 4. COMPOSITION IS CONCATENATION - words chain naturally
# 5. TRACE YOUR STACK - the debugger is pen and paper!
#
# Happy stack hacking!
# ============================================================================
