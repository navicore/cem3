# Shopping Cart REST Server
#
# A complete example demonstrating:
# - HTTP REST API with multiple endpoints
# - SQLite persistence with prepared statements
# - Database transactions for checkout
# - URL query parameter parsing
# - Concurrent request handling with strands
#
# Build:
#   seqc --ffi-manifest examples/shopping-cart/sqlite.toml \
#        examples/shopping-cart/shopping-cart.seq -o shopping-cart
#
# Run:
#   ./shopping-cart
#
# Test with curl:
#   curl http://localhost:8080/products          # List products
#   curl http://localhost:8080/cart              # View cart
#   curl -X POST "http://localhost:8080/cart/add?product=1&qty=2"
#   curl -X POST "http://localhost:8080/cart/remove?id=1"
#   curl -X POST http://localhost:8080/cart/checkout
#
# Check database:
#   sqlite3 shop.db "SELECT * FROM products"
#   sqlite3 shop.db "SELECT * FROM cart_items"
#   sqlite3 shop.db "SELECT * FROM orders"

# SQLite FFI functions provided via --ffi-manifest (no include needed)

include std:stack-utils

# =============================================================================
# SQLite Constants and Helpers
# =============================================================================

: SQLITE_OK   ( -- Int ) 0 ;
: SQLITE_ROW  ( -- Int ) 100 ;
: SQLITE_DONE ( -- Int ) 101 ;

: db-ok? ( Int -- Int ) SQLITE_OK i.= ;
: db-row? ( Int -- Int ) SQLITE_ROW i.= ;

# =============================================================================
# HTTP Response Builders
# =============================================================================

: http-ok ( String -- String )
  dup string.length int->string
  "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\nContent-Length: " swap string.concat
  "\r\n\r\n" string.concat
  swap string.concat
;

: http-bad-request ( String -- String )
  dup string.length int->string
  "HTTP/1.1 400 Bad Request\r\nContent-Type: text/plain\r\nContent-Length: " swap string.concat
  "\r\n\r\n" string.concat
  swap string.concat
;

: http-not-found ( String -- String )
  dup string.length int->string
  "HTTP/1.1 404 Not Found\r\nContent-Type: text/plain\r\nContent-Length: " swap string.concat
  "\r\n\r\n" string.concat
  swap string.concat
;

: http-error ( String -- String )
  dup string.length int->string
  "HTTP/1.1 500 Internal Server Error\r\nContent-Type: text/plain\r\nContent-Length: " swap string.concat
  "\r\n\r\n" string.concat
  swap string.concat
;

# =============================================================================
# HTTP Request Parsing
# =============================================================================

: http-request-line ( String -- String )
  "\r\n" string.split 0 variant.field-at
;

: http-request-path ( String -- String )
  http-request-line " " string.split 1 variant.field-at
;

: http-request-method ( String -- String )
  http-request-line " " string.split 0 variant.field-at
;

# Extract path without query string: "/cart/add?x=1" -> "/cart/add"
: http-path-base ( String -- String )
  http-request-path
  "?" string.split 0 variant.field-at
;

# Extract query string: "/cart/add?x=1&y=2" -> "x=1&y=2" (or "" if none)
: http-query-string ( String -- String )
  http-request-path
  dup "?" string.contains if
    "?" string.split
    dup variant.field-count 1 i.> if
      1 variant.field-at
    else
      drop ""
    then
  else
    drop ""
  then
;

# Parse a query param: "product=1&qty=2" "product" -> "1"
# Returns empty string if not found
: query-param ( String String -- String )
  # Stack: ( query-string param-name )
  "=" string.concat  # ( query-string "param-name=" )
  over swap          # ( query-string query-string "param-name=" )
  string.split       # ( query-string variant )
  dup variant.field-count 1 i.> if
    # Found the param
    1 variant.field-at  # Get part after "param-name="
    "&" string.split 0 variant.field-at  # Get value before next &
    nip  # Drop original query-string
  else
    drop drop ""  # Not found
  then
;

# =============================================================================
# Database Initialization
# =============================================================================

: init-schema ( Int -- Int Int )
  # Stack: ( db -- db success? )
  # Create products table
  dup "CREATE TABLE IF NOT EXISTS products (
    id INTEGER PRIMARY KEY,
    name TEXT NOT NULL,
    price INTEGER NOT NULL,
    stock INTEGER NOT NULL
  )" db-exec db-ok? 0 i.= if
    0  # ( db 0 ) - failure
  else
    # Create cart_items table
    dup "CREATE TABLE IF NOT EXISTS cart_items (
      id INTEGER PRIMARY KEY,
      product_id INTEGER NOT NULL,
      quantity INTEGER NOT NULL,
      FOREIGN KEY (product_id) REFERENCES products(id)
    )" db-exec db-ok? 0 i.= if
      0  # ( db 0 ) - failure
    else
      # Create orders table
      dup "CREATE TABLE IF NOT EXISTS orders (
        id INTEGER PRIMARY KEY,
        total INTEGER NOT NULL,
        item_count INTEGER NOT NULL,
        created_at TEXT DEFAULT CURRENT_TIMESTAMP
      )" db-exec db-ok? 0 i.= if
        0  # ( db 0 ) - failure
      else
        1  # ( db 1 ) - success
      then
    then
  then
;

: seed-products ( Int -- Int )
  # Stack: ( db -- db )
  # Only seed if products table is empty
  dup "SELECT COUNT(*) FROM products" db-prepare
  db-ok? if
    # Stack: ( db stmt )
    dup db-step SQLITE_ROW i.= if
      dup 0 db-column-int 0 i.= if
        # Table is empty, seed it
        db-finalize drop
        dup "INSERT INTO products (name, price, stock) VALUES ('Apple', 100, 50)" db-exec drop
        dup "INSERT INTO products (name, price, stock) VALUES ('Banana', 75, 30)" db-exec drop
        dup "INSERT INTO products (name, price, stock) VALUES ('Orange', 120, 25)" db-exec drop
        dup "INSERT INTO products (name, price, stock) VALUES ('Milk', 350, 20)" db-exec drop
        dup "INSERT INTO products (name, price, stock) VALUES ('Bread', 250, 15)" db-exec drop
        "Seeded 5 products" io.write-line
      else
        db-finalize drop
        "Products already exist" io.write-line
      then
    else
      db-finalize drop
    then
  else
    # Prepare failed - finalize to prevent leak
    db-finalize drop
    "Warning: Could not check products table" io.write-line
  then
;

: init-db ( -- Int )
  # Returns: ( db-handle ) or 0 on failure
  "shop.db" db-open db-ok? if
    # Stack: ( db )
    init-schema if
      seed-products
      # db is on stack
    else
      "Failed to create schema" io.write-line
      drop 0
    then
  else
    drop  # drop the null handle
    "Failed to open database" io.write-line
    0
  then
;

# =============================================================================
# Product Queries
# =============================================================================

# Format a single product row as text
: format-product-row ( Int -- String )
  # Stack: ( stmt )
  # Columns: id(0), name(1), price(2), stock(3)
  # Simple format: just concatenate in order
  "  "
  over 0 db-column-int int->string string.concat
  ". " string.concat
  over 1 db-column-text string.concat
  " - $" string.concat
  over 2 db-column-int int->string string.concat
  " (stock: " string.concat
  over 3 db-column-int int->string string.concat
  ")" string.concat
  nip
;

# Recursive helper to collect product rows
: collect-products ( Int String -- String )
  # Stack: ( stmt accumulated )
  over db-step
  dup SQLITE_ROW i.= if
    drop  # drop step result
    # Get this row
    over format-product-row
    # Add newline if not first
    over string.length 0 i.> if
      "\n" swap string.concat
    then
    # Append to accumulated
    string.concat
    collect-products  # Recurse
  else
    SQLITE_DONE i.= if
      # Finalize and return
      swap db-finalize drop
    else
      # Error - finalize statement to prevent leak
      # Stack: ( stmt accumulated ) - step result already consumed by comparison
      swap db-finalize drop  # finalize stmt, drop result
      drop "ERROR"  # drop accumulated, return error
    then
  then
;

: list-products ( Int -- Int String )
  # Stack: ( db -- db result-string )
  dup "SELECT id, name, price, stock FROM products ORDER BY id" db-prepare
  # Stack after db-prepare: ( db stmt result )
  db-ok? if
    # Stack: ( db stmt )
    "" collect-products
    # Stack after collect: ( db result-string )
    dup "ERROR" string.equal? if
      drop "Error querying products"
    else
      "Products:\n" swap string.concat
    then
  else
    # Stack: ( db stmt ) - finalize to prevent leak (safe even if NULL)
    db-finalize drop "Error preparing query"
  then
;

# =============================================================================
# Cart Operations
# =============================================================================

: format-cart-row ( Int -- String )
  # Stack: ( stmt )
  # Columns: cart_id(0), product_name(1), quantity(2), price(3), subtotal(4)
  # Simple format: just concatenate in order
  "  #"
  over 0 db-column-int int->string string.concat
  ": " string.concat
  over 1 db-column-text string.concat
  " x " string.concat
  over 2 db-column-int int->string string.concat
  " @ $" string.concat
  over 3 db-column-int int->string string.concat
  " = $" string.concat
  over 4 db-column-int int->string string.concat
  nip
;

: collect-cart-items ( Int String -- String )
  over db-step
  dup SQLITE_ROW i.= if
    drop
    over format-cart-row
    over string.length 0 i.> if
      "\n" swap string.concat
    then
    string.concat
    collect-cart-items
  else
    SQLITE_DONE i.= if
      swap db-finalize drop
    else
      # Error - finalize statement to prevent leak
      # Stack: ( stmt accumulated ) - step result already consumed by comparison
      swap db-finalize drop  # finalize stmt, drop result
      drop "ERROR"  # drop accumulated, return error
    then
  then
;

: list-cart ( Int -- Int String )
  # Stack: ( db -- db result-string )
  dup "SELECT c.id, p.name, c.quantity, p.price, (c.quantity * p.price) as subtotal
       FROM cart_items c
       JOIN products p ON c.product_id = p.id
       ORDER BY c.id" db-prepare
  # Stack after db-prepare: ( db stmt result )
  db-ok? if
    # Stack: ( db stmt )
    "" collect-cart-items
    # Stack after collect: ( db result-string )
    dup "ERROR" string.equal? if
      drop "Error querying cart"
    else
      dup string.length 0 i.= if
        drop "Cart is empty"
      else
        "Cart:\n" swap string.concat
      then
    then
  else
    # Stack: ( db stmt ) - finalize to prevent leak (safe even if NULL)
    db-finalize drop "Error preparing cart query"
  then
;

# Add item to cart using prepared statement (prevents SQL injection)
: add-to-cart ( Int Int Int -- Int String )
  # Stack: ( db product_id qty -- db result )
  # First check if product exists and has sufficient stock
  2 pick "SELECT stock FROM products WHERE id = ?" db-prepare
  db-ok? if
    # Stack: ( db product_id qty stmt )
    dup 3 pick 1 swap db-bind-int drop  # bind product_id to param 1
    dup db-step SQLITE_ROW i.= if
      # Product exists, check stock
      dup 0 db-column-int  # ( db product_id qty stmt stock )
      3 pick               # ( db product_id qty stmt stock qty )
      i.< if
        # Not enough stock
        db-finalize 3drop
        "Insufficient stock"
      else
        db-finalize drop
        # Insert using prepared statement
        2 pick "INSERT INTO cart_items (product_id, quantity) VALUES (?, ?)" db-prepare
        db-ok? if
          # Stack: ( db product_id qty stmt )
          dup 3 pick 1 swap db-bind-int drop  # bind product_id
          dup 2 pick 2 swap db-bind-int drop  # bind qty
          dup db-step drop  # keep stmt, call step, drop result
          db-finalize 3drop  # finalize stmt and clean up
          "Added to cart"
        else
          # Stack: ( db product_id qty stmt ) - finalize and clean up, keep db
          db-finalize 3drop
          "Failed to prepare insert"
        then
      then
    else
      db-finalize 3drop
      "Product not found"
    then
  else
    # Stack: ( db product_id qty stmt ) - finalize and clean up, keep db
    db-finalize 3drop
    "Failed to prepare query"
  then
;

# Remove item from cart using prepared statement (prevents SQL injection)
: remove-from-cart ( Int Int -- Int String )
  # Stack: ( db cart_item_id -- db result )
  over "DELETE FROM cart_items WHERE id = ?" db-prepare
  db-ok? if
    # Stack: ( db cart_item_id stmt )
    dup rot 1 swap db-bind-int drop  # bind cart_item_id to param 1
    # Stack now: ( db stmt )
    dup db-step drop  # keep stmt, call step, drop result
    db-finalize drop  # finalize stmt
    "Removed from cart"
  else
    # Stack: ( db cart_item_id stmt ) - finalize and clean up, keep db
    db-finalize drop drop
    "Failed to prepare delete"
  then
;

# =============================================================================
# Checkout with Transaction
# =============================================================================

: calculate-cart-total ( Int -- Int Int Int )
  # Stack: ( db -- db total_price item_count )
  dup "SELECT COALESCE(SUM(c.quantity * p.price), 0), COALESCE(SUM(c.quantity), 0)
       FROM cart_items c
       JOIN products p ON c.product_id = p.id" db-prepare
  # Stack: ( db stmt result )
  db-ok? if
    # Stack: ( db stmt )
    dup db-step SQLITE_ROW i.= if
      # Stack: ( db stmt )
      dup 0 db-column-int  # ( db stmt total )
      over 1 db-column-int # ( db stmt total count )
      rot db-finalize drop # ( db total count )
    else
      # No row returned
      db-finalize drop
      0 0  # ( db 0 0 )
    then
  else
    # Prepare failed - finalize to prevent leak (safe even if NULL)
    db-finalize drop
    0 0  # ( db 0 0 )
  then
;

: check-stock-available ( Int -- Int Int )
  # Stack: ( db -- db sufficient? )
  # Check that all cart items have sufficient stock
  dup "SELECT COUNT(*) FROM cart_items c
       JOIN products p ON c.product_id = p.id
       WHERE c.quantity > p.stock" db-prepare
  db-ok? if
    dup db-step SQLITE_ROW i.= if
      dup 0 db-column-int 0 =  # True if count is 0 (no insufficient items)
      swap db-finalize drop
    else
      db-finalize drop
      0  # Error, return false
    then
  else
    # Prepare failed - finalize to prevent leak (safe even if NULL)
    db-finalize drop
    0  # Error, return false
  then
;

: update-stock ( Int -- Int Int )
  # Stack: ( db -- db success? )
  # Only update if stock won't go negative
  dup "UPDATE products SET stock = stock - (
    SELECT c.quantity FROM cart_items c WHERE c.product_id = products.id
  ) WHERE id IN (SELECT product_id FROM cart_items)
    AND stock >= (SELECT c.quantity FROM cart_items c WHERE c.product_id = products.id)" db-exec
  db-ok?
;

: create-order ( Int Int Int -- Int Int )
  # Stack: ( db total count -- db success? )
  # Use prepared statement to prevent SQL injection
  2 pick "INSERT INTO orders (total, item_count) VALUES (?, ?)" db-prepare
  db-ok? if
    # Stack: ( db total count stmt )
    dup 3 pick 1 swap db-bind-int drop  # bind total to param 1
    dup 2 pick 2 swap db-bind-int drop  # bind count to param 2
    dup db-step drop  # keep stmt, call step, drop result
    db-finalize 3drop  # finalize stmt and drop total count
    1  # success
  else
    # Stack: ( db total count stmt ) - finalize and clean up
    db-finalize 3drop
    0  # failure
  then
;

: clear-cart ( Int -- Int Int )
  # Stack: ( db -- db success? )
  dup "DELETE FROM cart_items" db-exec
  db-ok?
;

: checkout ( Int -- Int String )
  # Stack: ( db -- db result-string )
  # Calculate totals first
  calculate-cart-total
  # Stack: ( db total count )

  dup 0 i.= if
    # Empty cart
    drop drop
    "Cart is empty - nothing to checkout"
  else
    # Check stock availability before proceeding
    2 pick check-stock-available if
      drop  # drop extra db from 2 pick, now ( db total count )
      # Save values for later: total count
      2dup  # ( db total count total count )

      # Start transaction
      4 pick "BEGIN TRANSACTION" db-exec drop

      # Update stock
      4 pick update-stock if
        drop  # drop update result
        # Create order record ( db total count total count )
        4 pick rot rot create-order if
          drop  # drop create result
          # Clear cart ( db total count )
          2 pick clear-cart if
            drop  # drop clear result
            # Commit
            2 pick "COMMIT" db-exec drop

            # Build success message ( db total count )
            swap int->string swap int->string
            "Checkout successful! Order total: $" rot string.concat
            " (" string.concat
            swap string.concat
            " items)" string.concat
          else
            drop  # drop clear result
            2 pick "ROLLBACK" db-exec 3drop  # drop result, total, count
            "Checkout failed: could not clear cart"
          then
        else
          drop  # drop create result
          2 pick "ROLLBACK" db-exec 3drop  # drop result, total, count
          "Checkout failed: could not create order"
        then
      else
        drop  # drop extra db from 4 pick
        4 pick "ROLLBACK" db-exec drop  # stack is ( db total count total count )
        3drop drop  # clean up extra total count
        "Checkout failed: could not update stock"
      then
    else
      3drop  # drop extra db + total + count
      "Checkout failed: insufficient stock for one or more items"
    then
  then
;

# =============================================================================
# HTTP Router
# =============================================================================

: handle-get-products ( Int String -- Int String )
  # Stack: ( db request -- db response )
  drop
  list-products http-ok
;

: handle-get-cart ( Int String -- Int String )
  drop
  list-cart http-ok
;

: handle-add-to-cart ( Int String -- Int String )
  # Stack: ( db request -- db response )
  # Extract query params
  dup http-query-string
  dup "product" query-param
  swap "qty" query-param
  # Stack: ( db request product_str qty_str )

  # Validate params present
  over string.length 0 i.= if
    3drop
    "Missing 'product' parameter" http-bad-request
  else
    dup string.length 0 i.= if
      3drop
      "Missing 'qty' parameter" http-bad-request
    else
      # Stack: ( db request product_str qty_str )
      # Parse qty string to int
      string->int if
        # qty parsed successfully ( db request product_str qty_int )
        swap string->int if
          # product parsed successfully ( db request qty_int product_int )
          swap  # ( db request product_int qty_int )
          # Validate qty is positive
          dup 0 i.> if
            rot drop  # ( db product_int qty_int )
            add-to-cart
            http-ok
          else
            3drop
            "Quantity must be positive" http-bad-request
          then
        else
          3drop  # drop request, qty_int, product_int; keep db
          "Invalid product ID (must be a number)" http-bad-request
        then
      else
        3drop  # drop request, product_str, qty_int; keep db
        "Invalid quantity (must be a number)" http-bad-request
      then
    then
  then
;

: handle-remove-from-cart ( Int String -- Int String )
  dup http-query-string "id" query-param
  dup string.length 0 i.= if
    drop drop
    "Missing 'id' parameter" http-bad-request
  else
    # Parse id string to int
    string->int if
      # id parsed successfully ( db request id_int )
      nip  # drop request
      remove-from-cart
      http-ok
    else
      drop drop
      "Invalid id (must be a number)" http-bad-request
    then
  then
;

: handle-checkout ( Int String -- Int String )
  drop
  checkout http-ok
;

: route ( Int String -- Int String )
  # Stack: ( db request -- db response )
  # Check method and path
  dup http-request-method "GET" string.equal? if
    dup http-path-base "/products" string.equal? if
      handle-get-products
    else
      dup http-path-base "/cart" string.equal? if
        handle-get-cart
      else
        dup http-path-base "/" string.equal? if
          drop
          "Shopping Cart API\n\nEndpoints:\n  GET  /products - List products\n  GET  /cart - View cart\n  POST /cart/add?product=ID&qty=N - Add to cart\n  POST /cart/remove?id=N - Remove from cart\n  POST /cart/checkout - Complete purchase" http-ok
        else
          drop "Not found" http-not-found
        then
      then
    then
  else
    dup http-request-method "POST" string.equal? if
      dup http-path-base "/cart/add" string.equal? if
        handle-add-to-cart
      else
        dup http-path-base "/cart/remove" string.equal? if
          handle-remove-from-cart
        else
          dup http-path-base "/cart/checkout" string.equal? if
            handle-checkout
          else
            drop "Not found" http-not-found
          then
        then
      then
    else
      drop "Method not allowed" http-bad-request
    then
  then
;

# =============================================================================
# Connection Handling
# =============================================================================

: handle-connection ( Int -- )
  # Stack: ( socket -- )
  # Each request opens its own DB connection for simplicity
  "shop.db" db-open db-ok? if
    # Stack: ( socket db )
    swap dup tcp.read  # ( db socket request )
    rot                # ( socket request db )
    swap route         # ( socket db response )
    rot                # ( db response socket )
    tuck tcp.write     # ( db socket )
    tcp.close          # ( db )
    db-close drop      # close our db connection
  else
    # DB open failed
    drop  # drop null db handle
    "HTTP/1.1 500 Internal Server Error\r\nContent-Length: 13\r\n\r\nDatabase error"
    over tcp.write
    tcp.close
  then
;

: worker ( Int -- )
  # Stack: ( channel -- )
  dup chan.receive  # keep channel ID, get socket
  swap chan.close   # close the channel (no longer needed)
  handle-connection
;

: accept-loop ( Int -- )
  # Stack: ( listener -- )
  dup tcp.accept
  # Stack: ( listener client )

  chan.make
  # Stack: ( listener client chan )

  dup [ worker ] spawn
  # After dup: ( listener client chan chan )
  # After spawn: ( listener client chan chan strand_id )

  drop drop
  # After drops: ( listener client chan )

  # Send client through channel
  chan.send
  # Stack: ( listener )

  accept-loop
;

# =============================================================================
# Main Entry Point
# =============================================================================

: main ( -- )
  "Initializing Shopping Cart Server..." io.write-line

  # Initialize DB schema and seed data, then close the setup connection
  init-db
  dup 0 i.= if
    drop
    "Failed to initialize database" io.write-line
  else
    db-close drop  # Close the setup connection
    "Database initialized" io.write-line
    "" io.write-line
    "Starting server on port 8080..." io.write-line
    "API Endpoints:" io.write-line
    "  GET  http://localhost:8080/           - API info" io.write-line
    "  GET  http://localhost:8080/products   - List products" io.write-line
    "  GET  http://localhost:8080/cart       - View cart" io.write-line
    "  POST http://localhost:8080/cart/add?product=ID&qty=N" io.write-line
    "  POST http://localhost:8080/cart/remove?id=N" io.write-line
    "  POST http://localhost:8080/cart/checkout" io.write-line
    "" io.write-line

    8080 tcp.listen
    "Listening..." io.write-line
    accept-loop
  then
;
