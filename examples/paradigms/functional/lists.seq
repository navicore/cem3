# Functional Programming with Lists
#
# Lisp-style programming in Seq using the built-in List type.
# Demonstrates map, filter, fold and recursive list operations.
#
# Run: seqc build examples/paradigms/functional/lists.seq -o /tmp/lists && /tmp/lists

include std:list
include std:imath

# =============================================================================
# List Primitives (built-in)
# =============================================================================
#
# list.make     ( -- List )           Create empty list
# list.push     ( List V -- List )    Append element
# list.get      ( List Int -- V Bool) Get element at index
# list.length   ( List -- Int )       Number of elements
# list.map      ( List Quot -- List ) Apply function to each element
# list.filter   ( List Quot -- List ) Keep elements where predicate is true
# list.fold     ( List Acc Quot -- Acc ) Reduce list with accumulator
#
# Builder helpers (from std:list):
# list-of       ( -- List )           Alias for list.make
# lv            ( List V -- List )    Alias for list.push

# =============================================================================
# Recursive List Functions
# =============================================================================

# Sum using fold
: sum ( Variant -- Int )
  0 [ i.+ ] list.fold
;

# Product using fold
: product ( Variant -- Int )
  1 [ i.* ] list.fold
;

# Find maximum (assumes non-empty list)
# list.fold signature: ( list acc quot -- result )
# quotation receives ( acc elem ) and should return new acc
: maximum ( Variant -- Int )
  dup 0 list.get drop  # ( list first-element )
  [ 2dup i.> if drop else nip then ] list.fold
  # if acc > elem: drop elem, keep acc
  # else: nip acc, keep elem (the larger one)
;

# Find minimum (assumes non-empty list)
: minimum ( Variant -- Int )
  dup 0 list.get drop  # ( list first-element )
  [ 2dup i.< if drop else nip then ] list.fold
  # if acc < elem: drop elem, keep acc
  # else: nip acc, keep elem (the smaller one)
;

# Length using fold (demonstrating fold pattern)
: len ( Variant -- Int )
  0 [ drop 1 i.+ ] list.fold
;

# Note: List reversal would require a prepend operation not available
# in the current list primitives. The fold pattern works well for
# operations that accumulate values (sum, product, max, min).

# =============================================================================
# Higher-Order Function Demos
# =============================================================================

# Double each element
: double-each ( Variant -- Variant )
  [ 2 i.* ] list.map
;

# Square each element
: square-each ( Variant -- Variant )
  [ dup i.* ] list.map
;

# Keep only even numbers
: keep-evens ( Variant -- Variant )
  [ 2 mod 0 i.= ] list.filter
;

# Keep only odd numbers
: keep-odds ( Variant -- Variant )
  [ 2 mod 1 i.= ] list.filter
;

# Keep numbers greater than 10 (specific version since quotations don't capture)
: keep-gt-10 ( Variant -- Variant )
  [ 10 i.> ] list.filter
;

# =============================================================================
# Print Utilities
# =============================================================================

# Print list elements separated by spaces
: print-elements ( Variant Int -- )
  over list.length over i.<= if
    drop drop
  else
    # Print separator if not first element
    dup 0 i.> if " " io.write then
    # Get and print element
    2dup list.get drop int->string io.write
    # Next index
    1 i.+
    print-elements
  then
;

: print-list ( Variant -- )
  "(" io.write
  dup 0 print-elements
  drop
  ")" io.write-line
;

# =============================================================================
# Demo
# =============================================================================

: main ( -- Int )
  "=== Functional Programming Demo ===" io.write-line
  "" io.write-line

  # Create a list
  "--- List Construction ---" io.write-line
  list-of 1 lv 2 lv 3 lv 4 lv 5 lv
  "Original: " io.write dup print-list

  # Map: double each element
  "" io.write-line
  "--- Map (double each) ---" io.write-line
  dup double-each
  "Doubled:  " io.write dup print-list
  drop

  # Map: square each element
  "" io.write-line
  "--- Map (square each) ---" io.write-line
  dup square-each
  "Squared:  " io.write dup print-list
  drop

  # Filter: keep evens
  "" io.write-line
  "--- Filter (keep evens) ---" io.write-line
  dup keep-evens
  "Evens:    " io.write dup print-list
  drop

  # Filter: keep odds
  "" io.write-line
  "--- Filter (keep odds) ---" io.write-line
  dup keep-odds
  "Odds:     " io.write dup print-list
  drop

  # Fold: sum and product
  "" io.write-line
  "--- Fold (sum, product) ---" io.write-line
  dup sum int->string "Sum:      " io.write io.write-line
  dup product int->string "Product:  " io.write io.write-line

  # Maximum and minimum
  "" io.write-line
  "--- Aggregations ---" io.write-line
  dup maximum int->string "Max:      " io.write io.write-line
  dup minimum int->string "Min:      " io.write io.write-line
  dup len int->string "Length:   " io.write io.write-line

  # Chain operations (functional pipeline)
  "" io.write-line
  "--- Functional Pipeline ---" io.write-line
  "1..10 -> filter odds -> square -> sum:" io.write-line
  drop  # drop original list
  list-of 1 lv 2 lv 3 lv 4 lv 5 lv 6 lv 7 lv 8 lv 9 lv 10 lv
  keep-odds      # keep odds: 1,3,5,7,9
  square-each    # square: 1,9,25,49,81
  sum            # sum: 165
  int->string "Result:   " io.write io.write-line

  # Another pipeline
  "" io.write-line
  "1..10 -> double -> keep >10 -> sum:" io.write-line
  list-of 1 lv 2 lv 3 lv 4 lv 5 lv 6 lv 7 lv 8 lv 9 lv 10 lv
  double-each    # 2,4,6,8,10,12,14,16,18,20
  keep-gt-10     # 12,14,16,18,20
  sum            # 80
  int->string "Result:   " io.write io.write-line

  "" io.write-line
  "=== Demo Complete ===" io.write-line
  0
;
