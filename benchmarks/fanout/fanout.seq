# Fan-Out Benchmark
#
# Tests channel throughput with 1 producer and N concurrent consumer workers.
# Uses MPMC channels - multiple workers receive from the same channel.
# Workers yield after each receive to enable fair work distribution.
#
# NOTE: Success flags from channel operations are intentionally not checked
# in benchmarks to measure raw throughput. Production code should always
# check the Bool return from chan.send/chan.receive.
#
# Default: 1,000,000 messages, 100 workers

# Configuration
: num-messages ( -- Int ) 1000000 ;
: num-workers ( -- Int ) 100 ;

# Worker loop: receive messages until sentinel (-1)
# Yields after each receive for fair distribution
# ( work-chan done-chan count -- )
: worker-loop ( Channel Channel Int -- )
  2 pick chan.receive     # ( work done count value success )
  drop                    # drop success flag
  chan.yield              # yield to let other workers compete
  dup 0 i.< if            # sentinel check (-1 means stop)
    drop swap chan.send   # send count to done-chan
    drop drop             # drop success flag and work-chan
  else
    drop 1 i.add worker-loop
  then
;

# Worker entry point
# ( work-chan done-chan -- )
: worker ( Channel Channel -- )
  0 worker-loop
;

# Spawn N workers recursively
# ( work-chan done-chan n -- )
: spawn-workers ( Channel Channel Int -- )
  dup 0 i.> if
    2 pick 2 pick [ worker ] strand.spawn drop drop drop
    1 i.subtract spawn-workers
  else
    drop drop drop
  then
;

# Collect N results recursively
# ( done-chan total remaining -- total )
: collect-results ( Channel Int Int -- Int )
  dup 0 i.> if
    2 pick chan.receive   # ( done total remaining value success )
    drop                  # drop success flag
    rot i.add swap 1 i.subtract collect-results
  else
    drop swap drop
  then
;

# Producer: send n messages (no yields - batched for performance)
# ( work-chan n -- )
: producer ( Channel Int -- )
  dup 0 i.> if
    dup 2 pick chan.send  # send n to work-chan
    drop                  # drop success flag
    1 i.subtract producer
  else
    drop drop
  then
;

# Send N sentinel values to signal workers to stop
# ( work-chan n -- )
: send-sentinels ( Channel Int -- )
  dup 0 i.> if
    -1 2 pick chan.send  # send sentinel
    drop                 # drop success flag
    1 i.subtract send-sentinels
  else
    drop drop
  then
;

: main ( -- Int )
  chan.make               # work channel ( work )
  chan.make               # done channel ( work done )

  # Spawn workers
  2dup num-workers spawn-workers

  chan.yield              # let workers start

  # ( work done )
  swap                    # ( done work )

  # Start timing here, after setup
  time.nanos              # ( done work start )

  # Producer: send all messages (batched, no per-send yields)
  over num-messages producer  # ( done work start )

  chan.yield              # let workers process

  # Send sentinel values to all workers
  over num-workers send-sentinels  # ( done work start )

  chan.yield

  # End timing before collecting results
  time.nanos              # ( done work start end )

  # Calculate elapsed time
  swap i.subtract           # ( done work elapsed_ns )
  1000000 i.divide          # ( done work ms )

  # Clean up channels
  swap drop               # ( done ms )
  swap                    # ( ms done )

  # Collect results from all workers
  0 num-workers collect-results  # ( ms total )

  # Print results
  "Workers: " num-workers int->string string.concat io.write-line
  "Processed: " swap int->string string.concat " messages" string.concat io.write-line
  dup "Time: " swap int->string string.concat " ms" string.concat io.write-line

  # Calculate throughput: messages * 1000 / ms
  dup 0 i.= if
    drop 0
  else
    num-messages 1000 i.multiply swap i.divide
  then

  "Throughput: " swap int->string string.concat " msg/sec" string.concat io.write-line

  0
;
