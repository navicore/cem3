# Test weave with records and nested ADTs
#
# Verifies that weaves work correctly with complex types:
# - Records (unions with single variant) as yield/resume types
# - Nested ADTs (Option inside a record)
# - Proper value preservation through yield/resume cycle

# Option type for nullable values
union Option {
  None
  Some { value: Int }
}

# A record with an Int and a nested Option
union Record {
  Data { id: Int, result: Option }
}

# Helper: get id from record (field 0)
: record-id ( Record -- Int )
  0 variant.field-at ;

# Helper: get result from record (field 1)
: record-result ( Record -- Option )
  1 variant.field-at ;

# Helper: create a record
: make-data ( Int Option -- Record )
  Make-Data ;

# Simple transformer: doubles the id and wraps in Some
: transformer ( Ctx Record -- | Yield Record )
  # Get the id, double it, wrap in Some
  dup record-id 2 i.* Make-Some
  swap record-id swap
  make-data

  # Yield and wait for next
  yield

  # Recurse for next record
  transformer
;

# Test basic record yield/resume
: test-record-yield-resume ( -- )
  [ transformer ] strand.weave

  # Send record with id=5, expect back id=5, result=Some(10)
  5 Make-None make-data
  strand.resume
  test.assert                    # has_more should be true

  # Verify the returned record
  dup record-id 5 test.assert-eq  # id preserved
  record-result
  match
    None -> false test.assert    # Should be Some, not None
    Some { >value } ->
      10 test.assert-eq          # value should be 5*2=10
  end

  # Send another record with id=7
  7 Make-None make-data
  strand.resume
  test.assert

  dup record-id 7 test.assert-eq
  record-result
  match
    None -> false test.assert
    Some { >value } ->
      14 test.assert-eq          # 7*2=14
  end

  # Cancel the weave
  strand.weave-cancel
;

# Generator that yields records until id reaches 0
# Returns Ctx when done (weave completes naturally)
: countdown-gen ( Ctx Record -- Ctx | Yield Record )
  dup record-id 0 i.> if
    # id > 0: yield record with Some(id)
    # Stack: (Ctx Record)
    dup record-id              # (Ctx Record id)
    dup Make-Some              # (Ctx Record id Some(id))
    rot drop                   # (Ctx id Some(id)) - drop original Record
    make-data                  # (Ctx Record{id, Some(id)})
    yield                      # yields record, gets next record
    # Stack: (Ctx next-Record)
    countdown-gen
  else
    # id <= 0: drop record, keep Ctx, weave completes
    drop
  then
;

# Test weave completion with records
: test-record-completion ( -- )
  [ countdown-gen ] strand.weave

  # Start with id=3
  3 Make-None make-data
  strand.resume
  test.assert
  dup record-id 3 test.assert-eq
  record-result
  match
    None -> false test.assert
    Some { >value } -> 3 test.assert-eq
  end

  # Next: id=2
  2 Make-None make-data
  strand.resume
  test.assert
  dup record-id 2 test.assert-eq
  drop

  # Next: id=1
  1 Make-None make-data
  strand.resume
  test.assert
  dup record-id 1 test.assert-eq
  drop

  # Next: id=0 - should complete
  0 Make-None make-data
  strand.resume
  test.assert-not              # has_more should be false
  drop drop                    # drop placeholder and handle
;

# Test cancellation with records (no hanging)
: test-record-cancel ( -- )
  [ transformer ] strand.weave
  strand.weave-cancel
  # If we get here, cancellation worked
  true test.assert
;

# Test cancellation after partial resume with records
: test-record-cancel-after-resume ( -- )
  [ transformer ] strand.weave

  # One resume cycle
  42 Make-None make-data
  strand.resume
  test.assert
  dup record-id 42 test.assert-eq
  drop

  # Cancel
  strand.weave-cancel
  true test.assert
;
