# Tests for division operations with error handling
# Division operations now return ( Int Int -- Int Bool ) for safe error propagation

# =============================================================================
#                           INTEGER DIVISION
# =============================================================================

: test-divide-success ( -- )
  10 2 i./
  test.assert        # Bool should be true (success)
  5 test.assert-eq   # result should be 5
;

: test-divide-negative ( -- )
  -10 2 i./
  test.assert        # Bool should be true
  -5 test.assert-eq  # result should be -5
;

: test-divide-by-negative ( -- )
  10 -2 i./
  test.assert        # Bool should be true
  -5 test.assert-eq  # result should be -5
;

: test-divide-by-zero ( -- )
  10 0 i./
  not test.assert    # Bool should be false (failure)
  0 test.assert-eq   # result should be 0 on failure
;

: test-divide-zero-by-nonzero ( -- )
  0 5 i./
  test.assert        # Bool should be true
  0 test.assert-eq   # result should be 0
;

: test-divide-same-number ( -- )
  7 7 i./
  test.assert        # Bool should be true
  1 test.assert-eq   # result should be 1
;

# =============================================================================
#                           INTEGER MODULO
# =============================================================================

: test-modulo-success ( -- )
  10 3 i.%
  test.assert        # Bool should be true (success)
  1 test.assert-eq   # result should be 1 (10 % 3 = 1)
;

: test-modulo-no-remainder ( -- )
  10 5 i.%
  test.assert        # Bool should be true
  0 test.assert-eq   # result should be 0
;

: test-modulo-negative-dividend ( -- )
  -10 3 i.%
  test.assert        # Bool should be true
  -1 test.assert-eq  # result should be -1 (follows C semantics)
;

: test-modulo-by-zero ( -- )
  10 0 i.%
  not test.assert    # Bool should be false (failure)
  0 test.assert-eq   # result should be 0 on failure
;

: test-modulo-zero-by-nonzero ( -- )
  0 5 i.%
  test.assert        # Bool should be true
  0 test.assert-eq   # result should be 0
;

# =============================================================================
#                         LONG FORM ALIASES
# =============================================================================

: test-i-divide-alias ( -- )
  20 4 i.divide
  test.assert
  5 test.assert-eq
;

: test-i-modulo-alias ( -- )
  17 5 i.modulo
  test.assert
  2 test.assert-eq
;

# =============================================================================
#                         OVERFLOW EDGE CASES
# =============================================================================

# INT_MIN / -1 would mathematically overflow, but we use wrapping semantics
# INT_MIN = -9223372036854775808, and -INT_MIN wraps back to INT_MIN
: test-divide-int-min-by-neg-one ( -- )
  -9223372036854775808 -1 i./
  test.assert        # Bool should be true (wrapping is defined behavior)
  -9223372036854775808 test.assert-eq  # wraps to INT_MIN
;

# INT_MIN % -1 = 0, which is safe (no overflow in modulo)
: test-modulo-int-min-by-neg-one ( -- )
  -9223372036854775808 -1 i.%
  test.assert        # Bool should be true (no overflow for modulo)
  0 test.assert-eq   # result should be 0
;

# INT_MIN / 1 is fine (result is INT_MIN)
: test-divide-int-min-by-one ( -- )
  -9223372036854775808 1 i./
  test.assert        # Bool should be true
  -9223372036854775808 test.assert-eq
;

# INT_MIN / -2 is fine (result fits in i64)
: test-divide-int-min-by-neg-two ( -- )
  -9223372036854775808 -2 i./
  test.assert        # Bool should be true
  4611686018427387904 test.assert-eq  # INT_MIN / -2
;
