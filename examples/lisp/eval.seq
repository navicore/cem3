# Evaluator for SeqLisp - Using ADTs
#
# Currently supports:
# - Numbers: return as-is
# - Symbols: lookup in environment
# - Arithmetic: +, -, *, /
# - let: local binding
# - if: conditional
# - lambda: anonymous functions

include "parser"

# ============================================
# Environment (Association List)
#
# Env is a list of (String, Value) bindings
# Bindings use :Binding tag, closures use :Closure tag
# ============================================

: make-binding ( String Variant -- Variant )
  :Binding variant.make-2 ;

: binding-name ( Variant -- String )
  0 variant.field-at ;

: binding-value ( Variant -- Variant )
  1 variant.field-at ;

: env-empty ( -- Variant )
  snil ;

: env-extend ( String Variant Variant -- Variant )
  # Stack: Name Value Env
  rot rot make-binding swap scons ;

# ============================================
# Closure (Lambda Value)
#
# Closure is a 3-field variant (tag 60):
# - Field 0: Parameter list (cons list of symbols)
# - Field 1: Body expression
# - Field 2: Captured environment
# ============================================

: make-closure ( Variant Variant Variant -- Variant )
  :Closure variant.make-3 ;

: closure? ( Variant -- Bool )
  variant.tag :Closure symbol.= ;

: closure-params ( Variant -- Variant )
  0 variant.field-at ;

: closure-body ( Variant -- Variant )
  1 variant.field-at ;

: closure-env ( Variant -- Variant )
  2 variant.field-at ;

: env-lookup ( String Variant -- Variant )
  # Stack: Name Env
  # Returns the value or snil wrapped as empty SList if not found
  dup snil? if
    # Not found - return empty list as error marker
    drop drop snil slist
  else
    dup scar binding-name
    2 pick string.equal? if
      # Found it
      nip scar binding-value
    else
      # Keep looking
      scdr env-lookup
    then
  then ;

# ============================================
# Main Evaluator
# ============================================

# Simple eval without environment (for backward compatibility)
: eval ( Variant -- Variant )
  env-empty eval-with-env ;

# Eval with explicit environment
: eval-with-env ( Variant Variant -- Variant )
  # Stack: Expr Env
  over
  match
    SNum ->
      # Stack after match: ( Expr Env value )
      # SNum - return original Expr as-is
      drop drop  # ( Expr )
    SSym { >name } ->
      # Stack after match: ( Expr Env name )
      # SSym - lookup in environment
      rot drop  # ( Env name )
      swap env-lookup  # ( value )
    SList ->
      # Stack after match: ( Expr Env items )
      # SList - function application, drop items and use original Expr
      drop eval-list-with-env
  end
;

# ============================================
# List Evaluation (Function Application)
# ============================================

# Evaluate a symbol in function position (builtin dispatch)
: eval-sym-call ( Variant Variant Variant -- Variant )
  # Stack: Env List Head
  ssym-val swap rot eval-builtin-with-env
;

# Evaluate a list in function position (lambda call)
: eval-list-call ( Variant Variant Variant -- Variant )
  # Stack: Env List Head
  2 pick eval-with-env  # -> Env List EvaledHead
  dup closure? if
    # It's a closure - apply it
    rot rot scdr swap apply-closure
  else
    # Not a closure - error
    drop drop slist
  then
;

# Dispatch on function type
: eval-func-call ( Variant Variant Variant -- Variant )
  # Stack: Env List Head
  [ dup ssym? ]  [ eval-sym-call ]
  [ dup slist? ] [ eval-list-call ]
  [ true ]       [ drop slist nip ]  # Non-symbol, non-list
  3 cond
;

: eval-list-with-env ( Variant Variant -- Variant )
  # Stack: Expr Env
  swap slist-val
  dup snil? if
    # Empty list - return empty list
    nip slist
  else
    # Non-empty list: first element is function
    dup scar eval-func-call
  then
;

# ============================================
# Built-in Function Dispatch
# ============================================

: eval-builtin-with-env ( String Variant Variant -- Variant )
  # Stack: FuncName List Env
  rot
  [ dup "+" string.equal? ]      [ drop eval-add-with-env ]
  [ dup "-" string.equal? ]      [ drop eval-sub-with-env ]
  [ dup "*" string.equal? ]      [ drop eval-mul-with-env ]
  [ dup "/" string.equal? ]      [ drop eval-div-with-env ]
  [ dup "if" string.equal? ]     [ drop eval-if-with-env ]
  [ dup "let" string.equal? ]    [ drop eval-let-with-env ]
  [ dup "lambda" string.equal? ] [ drop eval-lambda-with-env ]
  [ true ]                       [ drop drop slist ]  # Unknown function
  8 cond
;

# ============================================
# Arithmetic Operations
# ============================================

: eval-add-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  swap scdr swap  # Skip the + -> RestList Env
  0 swap eval-fold-add-with-env snum
;

: eval-fold-add-with-env ( Variant Int Variant -- Int )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip
  else
    # Get first element and eval it
    2 pick scar over eval-with-env snum-val
    # Stack: List Acc Env FirstVal
    rot i.add
    # Stack: List Env NewAcc
    swap rot scdr rot rot
    # Stack: RestList NewAcc Env
    eval-fold-add-with-env
  then
;

: eval-sub-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  swap scdr
  dup snil? if
    drop drop 0 snum
  else
    dup scar 2 pick eval-with-env snum-val
    swap scdr
    dup snil? if
      # Unary minus: negate
      drop nip 0 swap i.subtract snum
    else
      # Binary minus: first - rest
      # Stack: Env FirstVal RestList -> need RestList FirstVal Env
      rot rot swap eval-fold-sub-with-env snum
    then
  then
;

: eval-fold-sub-with-env ( Variant Int Variant -- Int )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip
  else
    # Get first element and eval it
    2 pick scar over eval-with-env snum-val
    # Stack: List Acc Env FirstVal
    rot swap i.subtract
    # Stack: List Env NewAcc
    swap rot scdr rot rot
    # Stack: RestList NewAcc Env
    eval-fold-sub-with-env
  then
;

: eval-mul-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  swap scdr swap  # Skip the * -> RestList Env
  1 swap eval-fold-mul-with-env snum
;

: eval-fold-mul-with-env ( Variant Int Variant -- Int )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip
  else
    # Get first element and eval it
    2 pick scar over eval-with-env snum-val
    # Stack: List Acc Env FirstVal
    rot i.multiply
    # Stack: List Env NewAcc
    swap rot scdr rot rot
    # Stack: RestList NewAcc Env
    eval-fold-mul-with-env
  then
;

: eval-div-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  swap scdr
  dup snil? if
    drop drop 0 snum
  else
    dup scar 2 pick eval-with-env snum-val
    swap scdr
    dup snil? if
      drop nip snum
    else
      # Stack: Env FirstVal RestList -> need RestList FirstVal Env
      rot rot swap eval-fold-div-with-env snum
    then
  then
;

: eval-fold-div-with-env ( Variant Int Variant -- Int )
  # Stack: List Acc Env
  2 pick snil? if
    # List is empty, return Acc
    drop nip
  else
    # Get first element and eval it
    2 pick scar over eval-with-env snum-val
    # Stack: List Acc Env FirstVal
    rot swap i.divide
    # Stack: List Env NewAcc
    swap rot scdr rot rot
    # Stack: RestList NewAcc Env
    eval-fold-div-with-env
  then
;

# ============================================
# Conditional (if)
# ============================================

: eval-if-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  # List is (if cond then-expr else-expr)
  swap scdr  # Skip the if -> Env Args
  # Args is (cond then-expr else-expr)
  dup scar   # -> Env Args CondExpr
  2 pick     # -> Env Args CondExpr Env
  eval-with-env  # -> Env Args CondResult
  # Check if condition is numeric 0 (false)
  dup snum? if
    snum-val 0 i.= if
      # False (0) - eval else branch
      # Stack: Env Args
      scdr scdr scar swap eval-with-env
    else
      # True (non-zero) - eval then branch
      # Stack: Env Args
      scdr scar swap eval-with-env
    then
  else
    # Non-numeric condition - treat as true
    drop  # Drop CondResult -> Env Args
    scdr scar swap eval-with-env
  then
;

# ============================================
# Let Binding
# ============================================

: eval-let-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  # List is (let name value body)
  swap scdr  # Skip the 'let' -> Env Args
  dup scar ssym-val  # Get binding name -> Env Args Name
  swap scdr  # -> Env Name RestArgs
  dup scar  # -> Env Name RestArgs ValueExpr
  3 pick eval-with-env  # Evaluate value -> Env Name RestArgs Value
  rot  # -> Env RestArgs Value Name
  swap  # -> Env RestArgs Name Value
  3 pick  # -> Env RestArgs Name Value Env
  env-extend  # -> Env RestArgs NewEnv
  swap scdr scar  # Get body expr -> Env NewEnv BodyExpr
  swap  # -> Env BodyExpr NewEnv
  eval-with-env  # Evaluate body in new env -> Env Result
  nip  # -> Result
;

# ============================================
# Lambda
# ============================================

: eval-lambda-with-env ( Variant Variant -- Variant )
  # Stack: List Env
  # List is (lambda (params) body)
  swap scdr  # Skip 'lambda' -> Env Args
  # Args is ((params) body)
  dup scar slist-val  # Get params list -> Env Args Params
  swap scdr scar  # Get body -> Env Params Body
  rot  # -> Params Body Env
  make-closure  # -> Closure
;

# ============================================
# Closure Application
# ============================================

: apply-closure ( Variant Variant Variant -- Variant )
  # Stack: Closure Args CallerEnv
  # For simplicity, support single-parameter lambdas
  # 1. Evaluate the single argument
  # 2. Bind param to value in closure's env
  # 3. Evaluate body in extended env
  over scar  # -> Closure Args CallerEnv ArgExpr
  over eval-with-env  # -> Closure Args CallerEnv ArgVal
  # Now get closure components
  3 pick closure-params scar ssym-val  # -> Closure Args CallerEnv ArgVal ParamName
  swap  # -> Closure Args CallerEnv ParamName ArgVal
  4 pick closure-env  # -> Closure Args CallerEnv ParamName ArgVal ClosureEnv
  env-extend  # -> Closure Args CallerEnv ExtendedEnv
  # Evaluate body
  3 pick closure-body  # -> Closure Args CallerEnv ExtendedEnv Body
  swap eval-with-env  # -> Closure Args CallerEnv Result
  nip nip nip  # -> Result
;

# ============================================
# REPL Helper
# ============================================

: eval-print ( String -- )
  parse eval sexpr-to-string io.write-line ;
