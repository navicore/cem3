# Test bitwise operations

: test-band ( -- )
  0xFF 0x0F band 0x0F test.assert-eq
;

: test-bor ( -- )
  0xF0 0x0F bor 0xFF test.assert-eq
;

: test-bxor ( -- )
  0xFF 0x0F bxor 0xF0 test.assert-eq
;

: test-bnot ( -- )
  # bnot of 0 should have all bits set (i.e., -1 in two's complement)
  0 bnot -1 test.assert-eq
;

: test-shl ( -- )
  1 4 shl 16 test.assert-eq
;

: test-shr ( -- )
  16 4 shr 1 test.assert-eq
;

: test-popcount ( -- )
  0xFF popcount 8 test.assert-eq
;

: test-clz ( -- )
  # 1 has 63 leading zeros in a 64-bit int
  1 clz 63 test.assert-eq
;

: test-ctz ( -- )
  # 16 = 0b10000, has 4 trailing zeros
  16 ctz 4 test.assert-eq
;

: test-int-bits ( -- )
  int-bits 64 test.assert-eq
;

: test-hex-literals ( -- )
  0xFF 255 test.assert-eq
;

: test-binary-literals ( -- )
  0b1010 10 test.assert-eq
;

: test-shift-edge-cases ( -- )
  # Shift by 0
  42 0 shl 42 test.assert-eq
  # Shift by exactly 63 (last valid shift)
  1 63 shl -9223372036854775808 test.assert-eq
  # Shift by 64 (out of range, returns 0)
  1 64 shl 0 test.assert-eq
  # Shift by negative (out of range, returns 0)
  1 -1 shl 0 test.assert-eq
  # Logical right shift of negative (fills with 0, not sign-extended)
  -1 1 shr 9223372036854775807 test.assert-eq
;

: test-clz-ctz-edge-cases ( -- )
  # clz(0) should be 64
  0 clz 64 test.assert-eq
  # ctz(0) should be 64
  0 ctz 64 test.assert-eq
;

: test-popcount-edge-cases ( -- )
  # popcount(-1) = 64 (all bits set)
  -1 popcount 64 test.assert-eq
  # popcount(0) = 0
  0 popcount 0 test.assert-eq
;
