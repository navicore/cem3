# Test Result/Option Helpers
#
# Run with: seqc --output /tmp/test_result crates/compiler/stdlib/test_result.seq && /tmp/test_result

include std:result

# Define our test Result and Option types
union IntResult {
  Ok { value: Int }
  Err { error: String }
}

union IntOption {
  Some { value: Int }
  None
}

# =============================================================================
#                           TEST HELPERS
# =============================================================================

: test-pass ( String -- )
  "PASS: " swap string.concat io.write-line
;

: test-fail ( String -- )
  "FAIL: " swap string.concat io.write-line
;

# =============================================================================
#                           RESULT TESTS
# =============================================================================

: test-ok-predicate ( -- )
  42 Make-Ok
  result-ok? if
    drop "result-ok? on Ok" test-pass
  else
    drop "result-ok? on Ok" test-fail
  then
;

: test-ok-predicate-false ( -- )
  "error" Make-Err
  result-ok? if
    drop "result-ok? on Err should be false" test-fail
  else
    drop "result-ok? on Err returns false" test-pass
  then
;

: test-err-predicate ( -- )
  "error" Make-Err
  result-err? if
    drop "result-err? on Err" test-pass
  else
    drop "result-err? on Err" test-fail
  then
;

: test-err-predicate-false ( -- )
  42 Make-Ok
  result-err? if
    drop "result-err? on Ok should be false" test-fail
  else
    drop "result-err? on Ok returns false" test-pass
  then
;

# Test unwrap using variant.field-at directly (type-safe within our union)
: test-unwrap-ok ( -- )
  42 Make-Ok
  result-ok? if
    0 variant.field-at 42 = if
      "unwrap Ok value" test-pass
    else
      "unwrap Ok value" test-fail
    then
  else
    drop "unwrap Ok - not ok?" test-fail
  then
;

: test-unwrap-err-msg ( -- )
  "my error" Make-Err
  result-err? if
    0 variant.field-at "my error" string.equal? if
      "unwrap Err message" test-pass
    else
      "unwrap Err message" test-fail
    then
  else
    drop "unwrap Err - not err?" test-fail
  then
;

: test-result-unwrap-or-ok ( -- )
  42 Make-Ok 99 result-unwrap-or
  42 = if
    "result-unwrap-or on Ok" test-pass
  else
    "result-unwrap-or on Ok" test-fail
  then
;

: test-result-unwrap-or-err ( -- )
  "error" Make-Err 99 result-unwrap-or
  99 = if
    "result-unwrap-or on Err returns default" test-pass
  else
    "result-unwrap-or on Err" test-fail
  then
;

# =============================================================================
#                        RESULT COMBINATOR TESTS
# =============================================================================

# Helper: double a number and wrap in Ok
: double-ok ( Int -- IntResult )
  2 multiply Make-Ok
;

# Helper: return Err if not positive
: positive-or-err ( Int -- IntResult )
  dup 0 > if
    Make-Ok
  else
    drop "not positive" Make-Err
  then
;

: test-result-bind-ok-ok ( -- )
  5 Make-Ok [ double-ok ] result-bind
  result-ok? if
    0 variant.field-at 10 = if
      "result-bind Ok->Ok" test-pass
    else
      "result-bind Ok->Ok value" test-fail
    then
  else
    drop "result-bind Ok->Ok" test-fail
  then
;

: test-result-bind-ok-err ( -- )
  0 Make-Ok [ positive-or-err ] result-bind
  result-err? if
    drop "result-bind Ok->Err" test-pass
  else
    drop "result-bind Ok->Err" test-fail
  then
;

: test-result-bind-err ( -- )
  "original" Make-Err [ double-ok ] result-bind
  result-err? if
    0 variant.field-at "original" string.equal? if
      "result-bind Err passthrough" test-pass
    else
      "result-bind Err passthrough msg" test-fail
    then
  else
    drop "result-bind Err passthrough" test-fail
  then
;

: test-result-map-ok ( -- )
  5 Make-Ok [ 2 multiply ] result-map
  result-ok? if
    0 variant.field-at 10 = if
      "result-map Ok" test-pass
    else
      "result-map Ok value" test-fail
    then
  else
    drop "result-map Ok" test-fail
  then
;

: test-result-map-err ( -- )
  "error" Make-Err [ 2 multiply ] result-map
  result-err? if
    drop "result-map Err passthrough" test-pass
  else
    drop "result-map Err passthrough" test-fail
  then
;

# =============================================================================
#                           OPTION TESTS
# =============================================================================

: test-some-predicate ( -- )
  42 Make-Some
  option-some? if
    drop "option-some? on Some" test-pass
  else
    drop "option-some? on Some" test-fail
  then
;

: test-some-predicate-false ( -- )
  Make-None
  option-some? if
    drop "option-some? on None should be false" test-fail
  else
    drop "option-some? on None returns false" test-pass
  then
;

: test-none-predicate ( -- )
  Make-None
  option-none? if
    drop "option-none? on None" test-pass
  else
    drop "option-none? on None" test-fail
  then
;

: test-none-predicate-false ( -- )
  42 Make-Some
  option-none? if
    drop "option-none? on Some should be false" test-fail
  else
    drop "option-none? on Some returns false" test-pass
  then
;

: test-unwrap-some ( -- )
  42 Make-Some
  option-some? if
    0 variant.field-at 42 = if
      "unwrap Some value" test-pass
    else
      "unwrap Some value" test-fail
    then
  else
    drop "unwrap Some - not some?" test-fail
  then
;

: test-option-unwrap-or-some ( -- )
  42 Make-Some 99 option-unwrap-or
  42 = if
    "option-unwrap-or on Some" test-pass
  else
    "option-unwrap-or on Some" test-fail
  then
;

: test-option-unwrap-or-none ( -- )
  Make-None 99 option-unwrap-or
  99 = if
    "option-unwrap-or on None returns default" test-pass
  else
    "option-unwrap-or on None" test-fail
  then
;

# =============================================================================
#                        OPTION COMBINATOR TESTS
# =============================================================================

# Helper: return Some if positive, None otherwise
: positive-or-none ( Int -- IntOption )
  dup 0 > if
    Make-Some
  else
    drop Make-None
  then
;

: test-option-bind-some-some ( -- )
  5 Make-Some [ positive-or-none ] option-bind
  option-some? if
    0 variant.field-at 5 = if
      "option-bind Some->Some" test-pass
    else
      "option-bind Some->Some value" test-fail
    then
  else
    drop "option-bind Some->Some" test-fail
  then
;

: test-option-bind-some-none ( -- )
  0 Make-Some [ positive-or-none ] option-bind
  option-none? if
    drop "option-bind Some->None" test-pass
  else
    drop "option-bind Some->None" test-fail
  then
;

: test-option-bind-none ( -- )
  Make-None [ positive-or-none ] option-bind
  option-none? if
    drop "option-bind None passthrough" test-pass
  else
    drop "option-bind None passthrough" test-fail
  then
;

: test-option-map-some ( -- )
  5 Make-Some [ 2 multiply ] option-map
  option-some? if
    0 variant.field-at 10 = if
      "option-map Some" test-pass
    else
      "option-map Some value" test-fail
    then
  else
    drop "option-map Some" test-fail
  then
;

: test-option-map-none ( -- )
  Make-None [ 2 multiply ] option-map
  option-none? if
    drop "option-map None passthrough" test-pass
  else
    drop "option-map None passthrough" test-fail
  then
;

# =============================================================================
#                         CHAINING TESTS
# =============================================================================

: parse-positive ( String -- IntResult )
  string->int if
    dup 0 > if
      Make-Ok
    else
      drop "not positive" Make-Err
    then
  else
    drop "not a number" Make-Err
  then
;

: test-chain-success ( -- )
  "5" parse-positive
  [ 2 multiply Make-Ok ] result-bind
  [ 3 add Make-Ok ] result-bind
  result-ok? if
    0 variant.field-at 13 = if
      "chain success (5*2+3=13)" test-pass
    else
      "chain success value" test-fail
    then
  else
    drop "chain success" test-fail
  then
;

: test-chain-early-err ( -- )
  "-5" parse-positive
  [ 2 multiply Make-Ok ] result-bind
  [ 3 add Make-Ok ] result-bind
  result-err? if
    drop "chain early error" test-pass
  else
    drop "chain early error" test-fail
  then
;

# =============================================================================
#                               MAIN
# =============================================================================

: main ( -- Int )
  "=== Result/Option Helper Tests ===" io.write-line
  "" io.write-line

  "--- Result Predicate Tests ---" io.write-line
  test-ok-predicate
  test-ok-predicate-false
  test-err-predicate
  test-err-predicate-false

  "" io.write-line
  "--- Result Unwrap Tests ---" io.write-line
  test-unwrap-ok
  test-unwrap-err-msg
  test-result-unwrap-or-ok
  test-result-unwrap-or-err

  "" io.write-line
  "--- Result Combinator Tests ---" io.write-line
  test-result-bind-ok-ok
  test-result-bind-ok-err
  test-result-bind-err
  test-result-map-ok
  test-result-map-err

  "" io.write-line
  "--- Option Predicate Tests ---" io.write-line
  test-some-predicate
  test-some-predicate-false
  test-none-predicate
  test-none-predicate-false

  "" io.write-line
  "--- Option Unwrap Tests ---" io.write-line
  test-unwrap-some
  test-option-unwrap-or-some
  test-option-unwrap-or-none

  "" io.write-line
  "--- Option Combinator Tests ---" io.write-line
  test-option-bind-some-some
  test-option-bind-some-none
  test-option-bind-none
  test-option-map-some
  test-option-map-none

  "" io.write-line
  "--- Chaining Tests ---" io.write-line
  test-chain-success
  test-chain-early-err

  "" io.write-line
  "=== All tests complete ===" io.write-line
  0
;
