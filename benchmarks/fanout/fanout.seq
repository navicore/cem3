# Fan-Out Benchmark
#
# Tests channel throughput with 1 producer and N concurrent consumer workers.
# Uses MPMC channels - multiple workers receive from the same channel.
# Workers yield after each receive to enable fair work distribution.
#
# Default: 1,000,000 messages, 100 workers

# Configuration
: num-messages ( -- Int ) 1000000 ;
: num-workers ( -- Int ) 100 ;

# Worker loop: receive messages until sentinel (-1)
# Yields after each receive for fair distribution
# ( work-chan done-chan count -- )
: worker-loop ( Int Int Int -- )
  2 pick chan.receive     # ( work done count value )
  chan.yield              # yield to let other workers compete
  dup 0 < if              # sentinel check (-1 means stop)
    drop swap chan.send drop
  else
    drop 1 add worker-loop
  then
;

# Worker entry point
# ( work-chan done-chan -- )
: worker ( Int Int -- )
  0 worker-loop
;

# Spawn N workers recursively
# ( work-chan done-chan n -- )
: spawn-workers ( Int Int Int -- )
  dup 0 > if
    2 pick 2 pick [ worker ] spawn drop drop drop
    1 subtract spawn-workers
  else
    drop drop drop
  then
;

# Collect N results recursively
# ( done-chan total remaining -- total )
: collect-results ( Int Int Int -- Int )
  dup 0 > if
    2 pick chan.receive rot add swap 1 subtract collect-results
  else
    drop swap drop
  then
;

# Producer: send n messages (no yields - batched for performance)
# ( work-chan n -- )
: producer ( Int Int -- )
  dup 0 > if
    dup 2 pick chan.send
    1 subtract producer
  else
    drop drop
  then
;

# Send N sentinel values to signal workers to stop
# ( work-chan n -- )
: send-sentinels ( Int Int -- )
  dup 0 > if
    -1 2 pick chan.send
    1 subtract send-sentinels
  else
    drop drop
  then
;

: main ( -- Int )
  chan.make               # work channel ( work )
  chan.make               # done channel ( work done )

  # Spawn workers
  2dup num-workers spawn-workers

  chan.yield              # let workers start

  # ( work done )
  swap                    # ( done work )

  # Start timing here, after setup
  time.nanos              # ( done work start )

  # Producer: send all messages (batched, no per-send yields)
  over num-messages producer  # ( done work start )

  chan.yield              # let workers process

  # Send sentinel values to all workers
  over num-workers send-sentinels  # ( done work start )

  chan.yield

  # End timing before collecting results
  time.nanos              # ( done work start end )

  # Calculate elapsed time
  swap subtract           # ( done work elapsed_ns )
  1000000 divide          # ( done work ms )

  # Clean up channels
  swap drop               # ( done ms )
  swap                    # ( ms done )

  # Collect results from all workers
  0 num-workers collect-results  # ( ms total )

  # Print results
  "Workers: " num-workers int->string string.concat io.write-line
  "Processed: " swap int->string string.concat " messages" string.concat io.write-line
  dup "Time: " swap int->string string.concat " ms" string.concat io.write-line

  # Calculate throughput: messages * 1000 / ms
  dup 0 = if
    drop 0
  else
    num-messages 1000 multiply swap divide
  then

  "Throughput: " swap int->string string.concat " msg/sec" string.concat io.write-line

  0
;
