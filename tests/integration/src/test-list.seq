# Tests for list.seq utilities

include std:list

# Test list-of creates empty list
: test-list-of-empty ( -- )
  list-of
  list.length 0 test.assert-eq
;

# Test lv appends elements
: test-lv-appends ( -- )
  list-of 1 lv 2 lv 3 lv
  list.length 3 test.assert-eq
;

# Test list.get retrieves elements
: test-list-get ( -- )
  list-of 10 lv 20 lv 30 lv
  dup 0 list.get test.assert 10 test.assert-eq
  dup 1 list.get test.assert 20 test.assert-eq
  2 list.get test.assert 30 test.assert-eq
;

# Test list.get out of bounds returns false
: test-list-get-out-of-bounds ( -- )
  list-of 1 lv 2 lv
  dup 5 list.get not test.assert drop
  -1 list.get not test.assert drop
;

# Test list.set replaces elements
: test-list-set ( -- )
  list-of 1 lv 2 lv 3 lv
  1 99 list.set test.assert
  1 list.get test.assert 99 test.assert-eq
;

# Test list.set out of bounds returns false
: test-list-set-out-of-bounds ( -- )
  list-of 1 lv 2 lv
  5 99 list.set not test.assert
  drop
;

# Test list.empty? on empty list
: test-list-empty-true ( -- )
  list-of list.empty? test.assert
;

# Test list.empty? on non-empty list
: test-list-empty-false ( -- )
  list-of 1 lv list.empty? not test.assert
;

# Test chained builder pattern
: test-list-chained ( -- )
  list-of
    "a" lv
    "b" lv
    "c" lv
  dup list.length 3 test.assert-eq
  dup 0 list.get test.assert "a" string.equal? test.assert
  dup 1 list.get test.assert "b" string.equal? test.assert
  2 list.get test.assert "c" string.equal? test.assert
;

# Test list.map with list operations
: test-list-map ( -- )
  list-of 1 lv 2 lv 3 lv
  [ 2 i.* ] list.map
  dup 0 list.get test.assert 2 test.assert-eq
  dup 1 list.get test.assert 4 test.assert-eq
  2 list.get test.assert 6 test.assert-eq
;

# Test list.filter
: test-list-filter ( -- )
  list-of 1 lv 2 lv 3 lv 4 lv
  [ 2 i.> ] list.filter
  list.length 2 test.assert-eq
;

# Test list.fold
: test-list-fold ( -- )
  list-of 1 lv 2 lv 3 lv 4 lv
  0 [ i.+ ] list.fold
  10 test.assert-eq
;

# Test nested lists
: test-list-nested ( -- )
  # Build inner lists first
  list-of 1 lv 2 lv    # Stack: [1,2]
  list-of 3 lv 4 lv    # Stack: [1,2] [3,4]
  # Build outer list containing them (order: first built = first in outer)
  # Stack: [1,2] [3,4]
  # We want outer = [[1,2], [3,4]], so add [1,2] first, then [3,4]
  swap                 # Stack: [3,4] [1,2]
  list-of swap lv      # Stack: [3,4] [[1,2]]
  swap lv              # Stack: [[1,2], [3,4]]
  dup list.length 2 test.assert-eq
  # Get first inner list [1,2] and verify
  dup 0 list.get test.assert
  dup list.length 2 test.assert-eq
  0 list.get test.assert 1 test.assert-eq
  # Get second inner list [3,4]
  1 list.get test.assert
  1 list.get test.assert 4 test.assert-eq
;

# Test mixed types in list
: test-list-mixed-types ( -- )
  list-of "hello" lv 42 lv true lv
  dup list.length 3 test.assert-eq
  dup 0 list.get test.assert "hello" string.equal? test.assert
  dup 1 list.get test.assert 42 test.assert-eq
  2 list.get test.assert test.assert
;

# Test list.set preserves functional semantics (original unchanged)
: test-list-set-functional ( -- )
  list-of 1 lv 2 lv 3 lv
  dup 1 99 list.set test.assert
  # New list has 99 at index 1
  1 list.get test.assert 99 test.assert-eq
  # Original list still has 2 at index 1
  1 list.get test.assert 2 test.assert-eq
;
