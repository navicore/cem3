# YAML Standard Library for Seq
#
# YAML parsing implemented in Seq, validating that the stdlib/builtin
# balance allows building complex parsers without language changes.
#
# ## Usage
#
#   include std:yaml
#
#   : main ( -- Int )
#     "name: hello" yaml-parse
#     drop yaml-serialize write_line
#     0
#   ;
#
# ## Supported YAML Subset
#
# This parser supports:
# - Multi-line documents with multiple key-value pairs
# - Strings (unquoted single-line)
# - Numbers (integers and floats)
# - Booleans (true, false)
# - Null (null, ~)
# - Comments (# to end of line)
# - Blank lines (ignored)
#
# ## Not Supported
#
# - Nested objects (indentation-based nesting)
# - Arrays/lists (- item syntax)
# - Multi-line strings (| and > block scalars)
# - Quoted strings with escapes
# - Anchors and aliases (&, *)
# - Multiple documents (---)
#
# ## YAML Value Representation
#
# Reuses the same variant tags as JSON for compatibility:
# - Tag 0: YamlNull (no fields)
# - Tag 1: YamlBool (one Int field: 0 or 1)
# - Tag 2: YamlNumber (one Float field)
# - Tag 3: YamlString (one String field)
# - Tag 5: YamlObject (2N fields: key1 val1 key2 val2 ...)
#
# ## Serialization Limits
#
# Like JSON, serialization uses nested if/else chains:
# - Objects: 0-3 pairs serialize fully, 4+ show as "{...}"
#

# ============================================================================
# YAML Value Constructors
# ============================================================================

# Create a YAML null value
: yaml-null
  0 0 make-variant
;

# Create a YAML boolean (0 or 1)
: yaml-bool
  0 <> if 1 else 0 then
  1 1 make-variant
;

# Create a YAML number from a Float
: yaml-number
  1 2 make-variant
;

# Create a YAML string
: yaml-string
  1 3 make-variant
;

# Create an empty YAML object
: yaml-empty-object
  0 5 make-variant
;

# ============================================================================
# Functional Object Builder
# ============================================================================

# Add a key-value pair to a YAML object, returning a new object
# Stack: ( YamlObject YamlString YamlValue -- YamlObject' )
: yaml-obj-with
  rot rot variant-append swap variant-append
;

# ============================================================================
# Type Predicates
# ============================================================================

: yaml-null?
  dup variant-tag 0 =
;

: yaml-bool?
  dup variant-tag 1 =
;

: yaml-number?
  dup variant-tag 2 =
;

: yaml-string?
  dup variant-tag 3 =
;

: yaml-object?
  dup variant-tag 5 =
;

# ============================================================================
# Value Extractors
# ============================================================================

: yaml-unwrap-bool
  0 variant-field-at
;

: yaml-unwrap-number
  0 variant-field-at
;

: yaml-unwrap-string
  0 variant-field-at
;

# ============================================================================
# Scalar Value Parsing
# ============================================================================

# Parse a scalar value string into a YAML value
: yaml-parse-scalar
  # Check for null
  dup "null" string-equal if
    drop yaml-null
  else
  dup "~" string-equal if
    drop yaml-null
  else
  dup "true" string-equal if
    drop 1 yaml-bool
  else
  dup "false" string-equal if
    drop 0 yaml-bool
  else
  # Try as number
  dup string->float if
    swap drop yaml-number
  else
    drop yaml-string
  then then then then then
;

# ============================================================================
# Simple Single Key-Value Parser
# ============================================================================

# Find the colon position in a string
# Returns -1 if not found
: yaml-find-colon ( ..rest String -- ..rest Int )
  ":" string-find
;

# Extract substring before colon
: yaml-key-part ( ..rest String Int -- ..rest String )
  0 swap string-substring string-trim
;

# Extract substring after colon (stops at newline)
: yaml-value-part ( ..rest String Int -- ..rest String )
  1 add                        # position after colon
  over string-length           # str afterpos len
  over subtract                # str afterpos remaining
  string-substring             # value-with-possible-newline
  # Find and strip newline if present
  dup yaml-find-newline        # val nlpos
  dup 0 < if
    drop string-trim           # no newline, just trim
  else
    0 swap string-substring string-trim  # take before newline and trim
  then
;

# Parse a simple "key: value" line
# Stack: ( String -- YamlValue Int )
# Returns an object with one key-value pair, and success flag
: yaml-parse-line ( ..rest String -- ..rest Variant Int )
  dup yaml-find-colon
  dup 0 < if
    # No colon found - not a valid key-value
    drop drop yaml-empty-object 0
  else
    # Found colon at position
    # Stack: str colonpos
    over over yaml-key-part     # str colonpos key
    rot rot yaml-value-part     # key valuestr
    yaml-parse-scalar           # key value
    swap yaml-string            # value keystr
    swap                        # keystr value
    yaml-empty-object           # keystr value obj
    rot rot                     # obj keystr value
    yaml-obj-with               # obj'
    1
  then
;

# ============================================================================
# Multi-line YAML Parser
# ============================================================================

# Find newline position in a string
# Returns -1 if not found
: yaml-find-newline ( ..rest String -- ..rest Int )
  10 char->string string-find
;

# Check if string is empty or whitespace-only
: yaml-is-blank-line ( ..rest String -- ..rest Int )
  string-trim string-empty
;

# Check if string starts with # (comment)
: yaml-is-comment ( ..rest String -- ..rest Int )
  string-trim
  dup string-empty if
    drop 0
  else
    0 string-char-at 35 =
  then
;

# Parse one line and add to object if valid
# Stack: ( obj line -- obj' )
: yaml-parse-and-add ( ..rest Variant String -- ..rest Variant )
  dup yaml-is-blank-line if
    drop  # skip blank lines
  else
  dup yaml-is-comment if
    drop  # skip comments
  else
    dup yaml-find-colon
    dup 0 < if
      # No colon - skip invalid line
      drop drop
    else
      # Parse the key-value pair
      over over yaml-key-part     # obj line colonpos key
      rot rot yaml-value-part     # obj key valuestr
      yaml-parse-scalar           # obj key value
      swap yaml-string            # obj value keystr
      swap                        # obj keystr value
      yaml-obj-with               # obj'
    then
  then then
;

# Extract first line from a string
# Stack: ( str newlinepos -- line rest )
: yaml-split-at-newline ( ..rest String Int -- ..rest String String )
  # Stack: str nlpos
  over over                            # str nlpos str nlpos
  0 swap string-substring              # str nlpos line
  rot rot                              # line str nlpos
  1 add                                # line str afterpos
  over string-length over subtract     # line str afterpos remaining
  string-substring                     # line rest
;

# Parse multiple lines recursively
# Stack: ( obj str -- obj' )
# Processes lines until string is empty
: yaml-parse-lines ( ..rest Variant String -- ..rest Variant )
  dup string-empty if
    drop  # done
  else
    dup yaml-find-newline
    dup 0 < if
      # No more newlines - process final line
      drop yaml-parse-and-add
    else
      # Found newline at position
      # Stack: obj str newlinepos
      yaml-split-at-newline              # obj line rest (rest on top)
      swap                               # obj rest line (line on top)
      rot                                # rest line obj
      swap                               # rest obj line
      yaml-parse-and-add                 # rest obj'
      swap                               # obj' rest
      yaml-parse-lines                   # obj''
    then
  then
;

# Parse YAML - handles single or multi-line documents
: yaml-parse ( ..rest String -- ..rest Variant Int )
  yaml-empty-object swap yaml-parse-lines
  dup variant-field-count 0 > if 1 else 0 then
;

# ============================================================================
# Serialization
# ============================================================================

# Get a double-quote character
: yaml-quote-char
  34 char->string
;

# Serialize a YAML value to a JSON-like string
: yaml-serialize
  dup variant-tag

  dup 0 = if
    drop drop "null"
  else
  dup 1 = if
    drop yaml-unwrap-bool
    0 = if "false" else "true" then
  else
  dup 2 = if
    drop yaml-unwrap-number float->string
  else
  dup 3 = if
    drop yaml-unwrap-string
    yaml-quote-char swap string-concat yaml-quote-char string-concat
  else
  dup 5 = if
    drop yaml-serialize-object
  else
    drop drop "null"
  then then then then then
;

# Serialize an object
# Supports up to 3 pairs (same limit as JSON serializer)
: yaml-serialize-object
  dup variant-field-count
  dup 0 = if
    drop drop "{}"
  else
    dup 2 = if
      # 1 pair (2 fields)
      drop
      dup 0 variant-field-at yaml-serialize
      swap 1 variant-field-at yaml-serialize
      swap "{" swap string-concat ":" string-concat
      swap string-concat "}" string-concat
    else
      dup 4 = if
        # 2 pairs (4 fields)
        drop
        "{"
        over 0 variant-field-at yaml-serialize string-concat
        ":" string-concat
        over 1 variant-field-at yaml-serialize string-concat
        "," string-concat
        over 2 variant-field-at yaml-serialize string-concat
        ":" string-concat
        swap 3 variant-field-at yaml-serialize string-concat
        "}" string-concat
      else
        dup 6 = if
          # 3 pairs (6 fields)
          drop
          "{"
          over 0 variant-field-at yaml-serialize string-concat
          ":" string-concat
          over 1 variant-field-at yaml-serialize string-concat
          "," string-concat
          over 2 variant-field-at yaml-serialize string-concat
          ":" string-concat
          over 3 variant-field-at yaml-serialize string-concat
          "," string-concat
          over 4 variant-field-at yaml-serialize string-concat
          ":" string-concat
          swap 5 variant-field-at yaml-serialize string-concat
          "}" string-concat
        else
          drop drop "{...}"
        then
      then
    then
  then
;
