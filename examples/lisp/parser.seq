# Parser for SeqLisp - Using ADTs
#
# Converts token list to s-expressions

include "sexpr"
include "tokenizer"

# ============================================
# Type Definitions
# ============================================

union ParseResult {
  PResult { expr: Sexpr, remaining: TokenList }
}

# ============================================
# Parse Result Constructors and Accessors
# ============================================

: make-parse-result ( Sexpr TokenList -- ParseResult )
  Make-PResult ;

: result-expr ( ParseResult -- Sexpr )
  0 variant.field-at ;

: result-tokens ( ParseResult -- TokenList )
  1 variant.field-at ;

# ============================================
# Token Predicates
# ============================================

: is-lparen ( String -- Bool )
  "(" string.equal? ;

: is-rparen ( String -- Bool )
  ")" string.equal? ;

: is-digit ( Int -- Bool )
  dup 48 i.>= swap 57 i.<= and ;

: is-number-token ( String -- Bool )
  # Check if first char is a digit or minus followed by digit
  dup string.length 0 i.= if
    drop false
  else
    dup 0 string.char-at
    dup 45 i.= if
      # Starts with minus - check if length > 1 and second char is digit
      drop dup string.length 1 i.> if
        1 string.char-at is-digit
      else
        drop false
      then
    else
      is-digit nip
    then
  then
;

# ============================================
# Main Parser
# ============================================

: parse ( String -- Sexpr )
  tokenize parse-tokens result-expr ;

# Parse an atom (number or symbol)
: parse-atom ( TokenList String -- ParseResult )
  dup is-number-token if
    string->int drop snum swap tcdr make-parse-result
  else
    ssym swap tcdr make-parse-result
  then
;

# Parse a single token and return result
: parse-token ( TokenList String -- ParseResult )
  [ dup is-lparen ] [ drop tcdr parse-list ]
  [ dup is-rparen ] [ drop tcdr parse-tokens ]  # Skip unexpected )
  [ true ]          [ parse-atom ]
  3 cond
;

: parse-tokens ( TokenList -- ParseResult )
  dup tnil? if
    # Empty token list - return nil expression
    snil slist swap make-parse-result
  else
    dup tcar parse-token
  then
;

# Parse list contents until )
: parse-list ( TokenList -- ParseResult )
  # Input: token list after opening paren
  # Returns: (SList of elements, tokens after closing paren)
  snil swap parse-list-items
;

: parse-list-items ( SexprList TokenList -- ParseResult )
  # Stack: Acc Tokens (Tokens on top)
  dup tnil? if
    # Ran out of tokens - return accumulated list with empty token list
    drop list-reverse slist tnil make-parse-result
  else
    dup tcar is-rparen if
      # End of list - return accumulated list and tokens after )
      tcdr swap list-reverse slist swap make-parse-result
    else
      # Parse next element from Tokens
      dup parse-tokens
      # Stack: Acc Tokens ParseResult
      dup result-tokens
      # Stack: Acc Tokens ParseResult RemTokens
      swap result-expr
      # Stack: Acc Tokens RemTokens Expr
      rot drop
      # Stack: Acc RemTokens Expr
      rot
      # Stack: RemTokens Expr Acc
      scons
      # Stack: RemTokens NewAcc
      swap
      # Stack: NewAcc RemTokens
      parse-list-items
    then
  then
;

# Reverse a cons list
: list-reverse ( SexprList -- SexprList )
  snil list-reverse-loop ;

: list-reverse-loop ( SexprList SexprList -- SexprList )
  swap dup snil? if drop else
    dup scar rot scons swap scdr swap list-reverse-loop
  then
;

# ============================================
# Debug
# ============================================

: print-parse ( String -- )
  parse sexpr-to-string io.write-line ;
