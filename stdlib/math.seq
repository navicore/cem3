# Math Standard Library for cem3
#
# Common mathematical operations for integer arithmetic.
#
# ## Usage
#
# Since cem3 does not yet have a module system, these functions must be
# copied directly into your program file. For example:
#
#   # Your program
#   : abs ( Int -- Int )
#     dup 0 < if 0 swap subtract then ;
#
#   : main ( -- )
#     -5 abs ... ;
#
# ## Available Functions
#
# - abs: ( Int -- Int ) - Absolute value
# - max: ( Int Int -- Int ) - Maximum of two values
# - min: ( Int Int -- Int ) - Minimum of two values
# - mod: ( Int Int -- Int ) - Modulo operation (a mod b)
# - gcd: ( Int Int -- Int ) - Greatest common divisor (Euclidean algorithm)
# - pow: ( Int Int -- Int ) - Power (base^exp) - WARNING: Not tail-recursive
# - sign: ( Int -- Int ) - Sign function: returns -1, 0, or 1
# - square: ( Int -- Int ) - Square a number
# - clamp: ( Int min max -- Int ) - Clamp value between min and max
#
# ## Notes
#
# - All operations use wrapping integer arithmetic (i64)
# - Recursive functions (gcd, pow) may stack overflow for very large inputs
# - Division by zero will panic at runtime
#
# ## Examples
#
#   48 18 gcd          # Returns 6
#   2 10 pow           # Returns 1024
#   15 0 100 clamp     # Returns 15 (within range)
#   -5 abs             # Returns 5
#

# Absolute value
# Both branches must have identical stack effects for type checker
: abs ( Int -- Int )
  dup dup 0 < if
    # Stack: n n, n < 0, so compute 0 - n
    nip 0 swap subtract
  else
    # Stack: n n, n >= 0, keep original
    drop
  then
;

# Maximum of two values
: max ( Int Int -- Int )
  over over > if
    drop
  else
    nip
  then
;

# Minimum of two values
: min ( Int Int -- Int )
  over over < if
    drop
  else
    nip
  then
;

# Modulo operation: a mod b
: mod ( Int Int -- Int )
  over over
  divide
  multiply
  subtract
;

# Greatest common divisor (Euclidean algorithm)
: gcd ( Int Int -- Int )
  dup 0 = if
    drop
  else
    over over mod
    rot drop
    gcd
  then
;

# Power (base^exp using recursion)
: pow ( Int Int -- Int )
  dup 0 = if
    drop drop 1
  else
    dup 1 = if
      drop
    else
      over
      swap 1 subtract
      pow
      multiply
    then
  then
;

# Sign function: returns -1, 0, or 1
: sign ( Int -- Int )
  dup 0 = if
    drop 0
  else
    dup 0 < if
      drop 0 1 subtract
    else
      drop 1
    then
  then
;

# Square
: square ( Int -- Int )
  dup multiply
;

# Clamp value between min and max
# Stack: ( value min max -- clamped )
# Returns: min if value < min, max if value > max, else value
: clamp ( Int Int Int -- Int )
  # Stack: value min max
  rot rot
  # Stack: max value min
  over over < if
    # value < min, return min
    nip nip
  else
    # value >= min
    drop
    # Stack: max value
    over over > if
      # value > max, return max
      nip
    else
      # min <= value <= max, return value
      drop
    then
  then
;
